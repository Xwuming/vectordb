// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vectordb_rpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vectordb_5frpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vectordb_5frpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vectordb_5frpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vectordb_5frpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[36]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vectordb_5frpc_2eproto;
namespace vectordb_rpc {
class AnnoyParam;
class AnnoyParamDefaultTypeInternal;
extern AnnoyParamDefaultTypeInternal _AnnoyParam_default_instance_;
class BuildIndexReply;
class BuildIndexReplyDefaultTypeInternal;
extern BuildIndexReplyDefaultTypeInternal _BuildIndexReply_default_instance_;
class BuildIndexRequest;
class BuildIndexRequestDefaultTypeInternal;
extern BuildIndexRequestDefaultTypeInternal _BuildIndexRequest_default_instance_;
class CreateTableReply;
class CreateTableReplyDefaultTypeInternal;
extern CreateTableReplyDefaultTypeInternal _CreateTableReply_default_instance_;
class CreateTableRequest;
class CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class DescribeReply;
class DescribeReplyDefaultTypeInternal;
extern DescribeReplyDefaultTypeInternal _DescribeReply_default_instance_;
class DescribeRequest;
class DescribeRequestDefaultTypeInternal;
extern DescribeRequestDefaultTypeInternal _DescribeRequest_default_instance_;
class DistKeyReply;
class DistKeyReplyDefaultTypeInternal;
extern DistKeyReplyDefaultTypeInternal _DistKeyReply_default_instance_;
class DistKeyRequest;
class DistKeyRequestDefaultTypeInternal;
extern DistKeyRequestDefaultTypeInternal _DistKeyRequest_default_instance_;
class GetKNNReply;
class GetKNNReplyDefaultTypeInternal;
extern GetKNNReplyDefaultTypeInternal _GetKNNReply_default_instance_;
class GetKNNRequest;
class GetKNNRequestDefaultTypeInternal;
extern GetKNNRequestDefaultTypeInternal _GetKNNRequest_default_instance_;
class GetVecReply;
class GetVecReplyDefaultTypeInternal;
extern GetVecReplyDefaultTypeInternal _GetVecReply_default_instance_;
class GetVecRequest;
class GetVecRequestDefaultTypeInternal;
extern GetVecRequestDefaultTypeInternal _GetVecRequest_default_instance_;
class Index;
class IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class InfoReply;
class InfoReplyDefaultTypeInternal;
extern InfoReplyDefaultTypeInternal _InfoReply_default_instance_;
class InfoRequest;
class InfoRequestDefaultTypeInternal;
extern InfoRequestDefaultTypeInternal _InfoRequest_default_instance_;
class Int32;
class Int32DefaultTypeInternal;
extern Int32DefaultTypeInternal _Int32_default_instance_;
class KNNGraphParam;
class KNNGraphParamDefaultTypeInternal;
extern KNNGraphParamDefaultTypeInternal _KNNGraphParam_default_instance_;
class KNNKey;
class KNNKeyDefaultTypeInternal;
extern KNNKeyDefaultTypeInternal _KNNKey_default_instance_;
class KNNValue;
class KNNValueDefaultTypeInternal;
extern KNNValueDefaultTypeInternal _KNNValue_default_instance_;
class KeysReply;
class KeysReplyDefaultTypeInternal;
extern KeysReplyDefaultTypeInternal _KeysReply_default_instance_;
class KeysRequest;
class KeysRequestDefaultTypeInternal;
extern KeysRequestDefaultTypeInternal _KeysRequest_default_instance_;
class Partition;
class PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class PingReply;
class PingReplyDefaultTypeInternal;
extern PingReplyDefaultTypeInternal _PingReply_default_instance_;
class PingRequest;
class PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PutVecReply;
class PutVecReplyDefaultTypeInternal;
extern PutVecReplyDefaultTypeInternal _PutVecReply_default_instance_;
class PutVecRequest;
class PutVecRequestDefaultTypeInternal;
extern PutVecRequestDefaultTypeInternal _PutVecRequest_default_instance_;
class Replica;
class ReplicaDefaultTypeInternal;
extern ReplicaDefaultTypeInternal _Replica_default_instance_;
class ShowTablesReply;
class ShowTablesReplyDefaultTypeInternal;
extern ShowTablesReplyDefaultTypeInternal _ShowTablesReply_default_instance_;
class ShowTablesRequest;
class ShowTablesRequestDefaultTypeInternal;
extern ShowTablesRequestDefaultTypeInternal _ShowTablesRequest_default_instance_;
class Table;
class TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableNames;
class TableNamesDefaultTypeInternal;
extern TableNamesDefaultTypeInternal _TableNames_default_instance_;
class VEngineMeta;
class VEngineMetaDefaultTypeInternal;
extern VEngineMetaDefaultTypeInternal _VEngineMeta_default_instance_;
class Vec;
class VecDefaultTypeInternal;
extern VecDefaultTypeInternal _Vec_default_instance_;
class VecDt;
class VecDtDefaultTypeInternal;
extern VecDtDefaultTypeInternal _VecDt_default_instance_;
class VecObj;
class VecObjDefaultTypeInternal;
extern VecObjDefaultTypeInternal _VecObj_default_instance_;
}  // namespace vectordb_rpc
PROTOBUF_NAMESPACE_OPEN
template<> ::vectordb_rpc::AnnoyParam* Arena::CreateMaybeMessage<::vectordb_rpc::AnnoyParam>(Arena*);
template<> ::vectordb_rpc::BuildIndexReply* Arena::CreateMaybeMessage<::vectordb_rpc::BuildIndexReply>(Arena*);
template<> ::vectordb_rpc::BuildIndexRequest* Arena::CreateMaybeMessage<::vectordb_rpc::BuildIndexRequest>(Arena*);
template<> ::vectordb_rpc::CreateTableReply* Arena::CreateMaybeMessage<::vectordb_rpc::CreateTableReply>(Arena*);
template<> ::vectordb_rpc::CreateTableRequest* Arena::CreateMaybeMessage<::vectordb_rpc::CreateTableRequest>(Arena*);
template<> ::vectordb_rpc::DescribeReply* Arena::CreateMaybeMessage<::vectordb_rpc::DescribeReply>(Arena*);
template<> ::vectordb_rpc::DescribeRequest* Arena::CreateMaybeMessage<::vectordb_rpc::DescribeRequest>(Arena*);
template<> ::vectordb_rpc::DistKeyReply* Arena::CreateMaybeMessage<::vectordb_rpc::DistKeyReply>(Arena*);
template<> ::vectordb_rpc::DistKeyRequest* Arena::CreateMaybeMessage<::vectordb_rpc::DistKeyRequest>(Arena*);
template<> ::vectordb_rpc::GetKNNReply* Arena::CreateMaybeMessage<::vectordb_rpc::GetKNNReply>(Arena*);
template<> ::vectordb_rpc::GetKNNRequest* Arena::CreateMaybeMessage<::vectordb_rpc::GetKNNRequest>(Arena*);
template<> ::vectordb_rpc::GetVecReply* Arena::CreateMaybeMessage<::vectordb_rpc::GetVecReply>(Arena*);
template<> ::vectordb_rpc::GetVecRequest* Arena::CreateMaybeMessage<::vectordb_rpc::GetVecRequest>(Arena*);
template<> ::vectordb_rpc::Index* Arena::CreateMaybeMessage<::vectordb_rpc::Index>(Arena*);
template<> ::vectordb_rpc::InfoReply* Arena::CreateMaybeMessage<::vectordb_rpc::InfoReply>(Arena*);
template<> ::vectordb_rpc::InfoRequest* Arena::CreateMaybeMessage<::vectordb_rpc::InfoRequest>(Arena*);
template<> ::vectordb_rpc::Int32* Arena::CreateMaybeMessage<::vectordb_rpc::Int32>(Arena*);
template<> ::vectordb_rpc::KNNGraphParam* Arena::CreateMaybeMessage<::vectordb_rpc::KNNGraphParam>(Arena*);
template<> ::vectordb_rpc::KNNKey* Arena::CreateMaybeMessage<::vectordb_rpc::KNNKey>(Arena*);
template<> ::vectordb_rpc::KNNValue* Arena::CreateMaybeMessage<::vectordb_rpc::KNNValue>(Arena*);
template<> ::vectordb_rpc::KeysReply* Arena::CreateMaybeMessage<::vectordb_rpc::KeysReply>(Arena*);
template<> ::vectordb_rpc::KeysRequest* Arena::CreateMaybeMessage<::vectordb_rpc::KeysRequest>(Arena*);
template<> ::vectordb_rpc::Partition* Arena::CreateMaybeMessage<::vectordb_rpc::Partition>(Arena*);
template<> ::vectordb_rpc::PingReply* Arena::CreateMaybeMessage<::vectordb_rpc::PingReply>(Arena*);
template<> ::vectordb_rpc::PingRequest* Arena::CreateMaybeMessage<::vectordb_rpc::PingRequest>(Arena*);
template<> ::vectordb_rpc::PutVecReply* Arena::CreateMaybeMessage<::vectordb_rpc::PutVecReply>(Arena*);
template<> ::vectordb_rpc::PutVecRequest* Arena::CreateMaybeMessage<::vectordb_rpc::PutVecRequest>(Arena*);
template<> ::vectordb_rpc::Replica* Arena::CreateMaybeMessage<::vectordb_rpc::Replica>(Arena*);
template<> ::vectordb_rpc::ShowTablesReply* Arena::CreateMaybeMessage<::vectordb_rpc::ShowTablesReply>(Arena*);
template<> ::vectordb_rpc::ShowTablesRequest* Arena::CreateMaybeMessage<::vectordb_rpc::ShowTablesRequest>(Arena*);
template<> ::vectordb_rpc::Table* Arena::CreateMaybeMessage<::vectordb_rpc::Table>(Arena*);
template<> ::vectordb_rpc::TableNames* Arena::CreateMaybeMessage<::vectordb_rpc::TableNames>(Arena*);
template<> ::vectordb_rpc::VEngineMeta* Arena::CreateMaybeMessage<::vectordb_rpc::VEngineMeta>(Arena*);
template<> ::vectordb_rpc::Vec* Arena::CreateMaybeMessage<::vectordb_rpc::Vec>(Arena*);
template<> ::vectordb_rpc::VecDt* Arena::CreateMaybeMessage<::vectordb_rpc::VecDt>(Arena*);
template<> ::vectordb_rpc::VecObj* Arena::CreateMaybeMessage<::vectordb_rpc::VecObj>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vectordb_rpc {

// ===================================================================

class KNNKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.KNNKey) */ {
 public:
  KNNKey();
  virtual ~KNNKey();

  KNNKey(const KNNKey& from);
  KNNKey(KNNKey&& from) noexcept
    : KNNKey() {
    *this = ::std::move(from);
  }

  inline KNNKey& operator=(const KNNKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline KNNKey& operator=(KNNKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KNNKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KNNKey* internal_default_instance() {
    return reinterpret_cast<const KNNKey*>(
               &_KNNKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(KNNKey* other);
  friend void swap(KNNKey& a, KNNKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KNNKey* New() const final {
    return CreateMaybeMessage<KNNKey>(nullptr);
  }

  KNNKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KNNKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KNNKey& from);
  void MergeFrom(const KNNKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KNNKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.KNNKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // int32 sequence = 2;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 sequence() const;
  void set_sequence(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.KNNKey)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::int32 sequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class KNNValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.KNNValue) */ {
 public:
  KNNValue();
  virtual ~KNNValue();

  KNNValue(const KNNValue& from);
  KNNValue(KNNValue&& from) noexcept
    : KNNValue() {
    *this = ::std::move(from);
  }

  inline KNNValue& operator=(const KNNValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline KNNValue& operator=(KNNValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KNNValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KNNValue* internal_default_instance() {
    return reinterpret_cast<const KNNValue*>(
               &_KNNValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(KNNValue* other);
  friend void swap(KNNValue& a, KNNValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KNNValue* New() const final {
    return CreateMaybeMessage<KNNValue>(nullptr);
  }

  KNNValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KNNValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KNNValue& from);
  void MergeFrom(const KNNValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KNNValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.KNNValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.KNNValue)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  float distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Int32 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.Int32) */ {
 public:
  Int32();
  virtual ~Int32();

  Int32(const Int32& from);
  Int32(Int32&& from) noexcept
    : Int32() {
    *this = ::std::move(from);
  }

  inline Int32& operator=(const Int32& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32& operator=(Int32&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Int32& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32* internal_default_instance() {
    return reinterpret_cast<const Int32*>(
               &_Int32_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Int32* other);
  friend void swap(Int32& a, Int32& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32* New() const final {
    return CreateMaybeMessage<Int32>(nullptr);
  }

  Int32* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Int32>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Int32& from);
  void MergeFrom(const Int32& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.Int32";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 data() const;
  void set_data(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.Int32)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class GetKNNRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.GetKNNRequest) */ {
 public:
  GetKNNRequest();
  virtual ~GetKNNRequest();

  GetKNNRequest(const GetKNNRequest& from);
  GetKNNRequest(GetKNNRequest&& from) noexcept
    : GetKNNRequest() {
    *this = ::std::move(from);
  }

  inline GetKNNRequest& operator=(const GetKNNRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKNNRequest& operator=(GetKNNRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKNNRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKNNRequest* internal_default_instance() {
    return reinterpret_cast<const GetKNNRequest*>(
               &_GetKNNRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetKNNRequest* other);
  friend void swap(GetKNNRequest& a, GetKNNRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetKNNRequest* New() const final {
    return CreateMaybeMessage<GetKNNRequest>(nullptr);
  }

  GetKNNRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKNNRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKNNRequest& from);
  void MergeFrom(const GetKNNRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKNNRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.GetKNNRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table = 1;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // string index_name = 4;
  void clear_index_name();
  static const int kIndexNameFieldNumber = 4;
  const std::string& index_name() const;
  void set_index_name(const std::string& value);
  void set_index_name(std::string&& value);
  void set_index_name(const char* value);
  void set_index_name(const char* value, size_t size);
  std::string* mutable_index_name();
  std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);

  // int32 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.GetKNNRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class VecDt :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.VecDt) */ {
 public:
  VecDt();
  virtual ~VecDt();

  VecDt(const VecDt& from);
  VecDt(VecDt&& from) noexcept
    : VecDt() {
    *this = ::std::move(from);
  }

  inline VecDt& operator=(const VecDt& from) {
    CopyFrom(from);
    return *this;
  }
  inline VecDt& operator=(VecDt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VecDt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VecDt* internal_default_instance() {
    return reinterpret_cast<const VecDt*>(
               &_VecDt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(VecDt* other);
  friend void swap(VecDt& a, VecDt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VecDt* New() const final {
    return CreateMaybeMessage<VecDt>(nullptr);
  }

  VecDt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VecDt>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VecDt& from);
  void MergeFrom(const VecDt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VecDt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.VecDt";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // string attach_value1 = 3;
  void clear_attach_value1();
  static const int kAttachValue1FieldNumber = 3;
  const std::string& attach_value1() const;
  void set_attach_value1(const std::string& value);
  void set_attach_value1(std::string&& value);
  void set_attach_value1(const char* value);
  void set_attach_value1(const char* value, size_t size);
  std::string* mutable_attach_value1();
  std::string* release_attach_value1();
  void set_allocated_attach_value1(std::string* attach_value1);

  // string attach_value2 = 4;
  void clear_attach_value2();
  static const int kAttachValue2FieldNumber = 4;
  const std::string& attach_value2() const;
  void set_attach_value2(const std::string& value);
  void set_attach_value2(std::string&& value);
  void set_attach_value2(const char* value);
  void set_attach_value2(const char* value, size_t size);
  std::string* mutable_attach_value2();
  std::string* release_attach_value2();
  void set_allocated_attach_value2(std::string* attach_value2);

  // string attach_value3 = 5;
  void clear_attach_value3();
  static const int kAttachValue3FieldNumber = 5;
  const std::string& attach_value3() const;
  void set_attach_value3(const std::string& value);
  void set_attach_value3(std::string&& value);
  void set_attach_value3(const char* value);
  void set_attach_value3(const char* value, size_t size);
  std::string* mutable_attach_value3();
  std::string* release_attach_value3();
  void set_allocated_attach_value3(std::string* attach_value3);

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.VecDt)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_value1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_value2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_value3_;
  float distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class GetKNNReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.GetKNNReply) */ {
 public:
  GetKNNReply();
  virtual ~GetKNNReply();

  GetKNNReply(const GetKNNReply& from);
  GetKNNReply(GetKNNReply&& from) noexcept
    : GetKNNReply() {
    *this = ::std::move(from);
  }

  inline GetKNNReply& operator=(const GetKNNReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKNNReply& operator=(GetKNNReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetKNNReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKNNReply* internal_default_instance() {
    return reinterpret_cast<const GetKNNReply*>(
               &_GetKNNReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetKNNReply* other);
  friend void swap(GetKNNReply& a, GetKNNReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetKNNReply* New() const final {
    return CreateMaybeMessage<GetKNNReply>(nullptr);
  }

  GetKNNReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetKNNReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetKNNReply& from);
  void MergeFrom(const GetKNNReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKNNReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.GetKNNReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vectordb_rpc.VecDt vecdts = 3;
  int vecdts_size() const;
  void clear_vecdts();
  static const int kVecdtsFieldNumber = 3;
  ::vectordb_rpc::VecDt* mutable_vecdts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::VecDt >*
      mutable_vecdts();
  const ::vectordb_rpc::VecDt& vecdts(int index) const;
  ::vectordb_rpc::VecDt* add_vecdts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::VecDt >&
      vecdts() const;

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.GetKNNReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::VecDt > vecdts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class VecObj :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.VecObj) */ {
 public:
  VecObj();
  virtual ~VecObj();

  VecObj(const VecObj& from);
  VecObj(VecObj&& from) noexcept
    : VecObj() {
    *this = ::std::move(from);
  }

  inline VecObj& operator=(const VecObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline VecObj& operator=(VecObj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VecObj& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VecObj* internal_default_instance() {
    return reinterpret_cast<const VecObj*>(
               &_VecObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(VecObj* other);
  friend void swap(VecObj& a, VecObj& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VecObj* New() const final {
    return CreateMaybeMessage<VecObj>(nullptr);
  }

  VecObj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VecObj>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VecObj& from);
  void MergeFrom(const VecObj& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VecObj* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.VecObj";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // string attach_value1 = 3;
  void clear_attach_value1();
  static const int kAttachValue1FieldNumber = 3;
  const std::string& attach_value1() const;
  void set_attach_value1(const std::string& value);
  void set_attach_value1(std::string&& value);
  void set_attach_value1(const char* value);
  void set_attach_value1(const char* value, size_t size);
  std::string* mutable_attach_value1();
  std::string* release_attach_value1();
  void set_allocated_attach_value1(std::string* attach_value1);

  // string attach_value2 = 4;
  void clear_attach_value2();
  static const int kAttachValue2FieldNumber = 4;
  const std::string& attach_value2() const;
  void set_attach_value2(const std::string& value);
  void set_attach_value2(std::string&& value);
  void set_attach_value2(const char* value);
  void set_attach_value2(const char* value, size_t size);
  std::string* mutable_attach_value2();
  std::string* release_attach_value2();
  void set_allocated_attach_value2(std::string* attach_value2);

  // string attach_value3 = 5;
  void clear_attach_value3();
  static const int kAttachValue3FieldNumber = 5;
  const std::string& attach_value3() const;
  void set_attach_value3(const std::string& value);
  void set_attach_value3(std::string&& value);
  void set_attach_value3(const char* value);
  void set_attach_value3(const char* value, size_t size);
  std::string* mutable_attach_value3();
  std::string* release_attach_value3();
  void set_allocated_attach_value3(std::string* attach_value3);

  // .vectordb_rpc.Vec vec = 2;
  bool has_vec() const;
  void clear_vec();
  static const int kVecFieldNumber = 2;
  const ::vectordb_rpc::Vec& vec() const;
  ::vectordb_rpc::Vec* release_vec();
  ::vectordb_rpc::Vec* mutable_vec();
  void set_allocated_vec(::vectordb_rpc::Vec* vec);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.VecObj)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_value1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_value2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_value3_;
  ::vectordb_rpc::Vec* vec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Vec :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.Vec) */ {
 public:
  Vec();
  virtual ~Vec();

  Vec(const Vec& from);
  Vec(Vec&& from) noexcept
    : Vec() {
    *this = ::std::move(from);
  }

  inline Vec& operator=(const Vec& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec& operator=(Vec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec* internal_default_instance() {
    return reinterpret_cast<const Vec*>(
               &_Vec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Vec* other);
  friend void swap(Vec& a, Vec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec* New() const final {
    return CreateMaybeMessage<Vec>(nullptr);
  }

  Vec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec& from);
  void MergeFrom(const Vec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.Vec";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:vectordb_rpc.Vec)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class KeysRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.KeysRequest) */ {
 public:
  KeysRequest();
  virtual ~KeysRequest();

  KeysRequest(const KeysRequest& from);
  KeysRequest(KeysRequest&& from) noexcept
    : KeysRequest() {
    *this = ::std::move(from);
  }

  inline KeysRequest& operator=(const KeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeysRequest& operator=(KeysRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeysRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeysRequest* internal_default_instance() {
    return reinterpret_cast<const KeysRequest*>(
               &_KeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(KeysRequest* other);
  friend void swap(KeysRequest& a, KeysRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeysRequest* New() const final {
    return CreateMaybeMessage<KeysRequest>(nullptr);
  }

  KeysRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeysRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeysRequest& from);
  void MergeFrom(const KeysRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeysRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.KeysRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table = 1;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.KeysRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class KeysReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.KeysReply) */ {
 public:
  KeysReply();
  virtual ~KeysReply();

  KeysReply(const KeysReply& from);
  KeysReply(KeysReply&& from) noexcept
    : KeysReply() {
    *this = ::std::move(from);
  }

  inline KeysReply& operator=(const KeysReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeysReply& operator=(KeysReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeysReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeysReply* internal_default_instance() {
    return reinterpret_cast<const KeysReply*>(
               &_KeysReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(KeysReply* other);
  friend void swap(KeysReply& a, KeysReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeysReply* New() const final {
    return CreateMaybeMessage<KeysReply>(nullptr);
  }

  KeysReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeysReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeysReply& from);
  void MergeFrom(const KeysReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeysReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.KeysReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.KeysReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class AnnoyParam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.AnnoyParam) */ {
 public:
  AnnoyParam();
  virtual ~AnnoyParam();

  AnnoyParam(const AnnoyParam& from);
  AnnoyParam(AnnoyParam&& from) noexcept
    : AnnoyParam() {
    *this = ::std::move(from);
  }

  inline AnnoyParam& operator=(const AnnoyParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnoyParam& operator=(AnnoyParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnnoyParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnnoyParam* internal_default_instance() {
    return reinterpret_cast<const AnnoyParam*>(
               &_AnnoyParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AnnoyParam* other);
  friend void swap(AnnoyParam& a, AnnoyParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnnoyParam* New() const final {
    return CreateMaybeMessage<AnnoyParam>(nullptr);
  }

  AnnoyParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnnoyParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnnoyParam& from);
  void MergeFrom(const AnnoyParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnoyParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.AnnoyParam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string distance_type = 1;
  void clear_distance_type();
  static const int kDistanceTypeFieldNumber = 1;
  const std::string& distance_type() const;
  void set_distance_type(const std::string& value);
  void set_distance_type(std::string&& value);
  void set_distance_type(const char* value);
  void set_distance_type(const char* value, size_t size);
  std::string* mutable_distance_type();
  std::string* release_distance_type();
  void set_allocated_distance_type(std::string* distance_type);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.AnnoyParam)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distance_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class KNNGraphParam :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.KNNGraphParam) */ {
 public:
  KNNGraphParam();
  virtual ~KNNGraphParam();

  KNNGraphParam(const KNNGraphParam& from);
  KNNGraphParam(KNNGraphParam&& from) noexcept
    : KNNGraphParam() {
    *this = ::std::move(from);
  }

  inline KNNGraphParam& operator=(const KNNGraphParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline KNNGraphParam& operator=(KNNGraphParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KNNGraphParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KNNGraphParam* internal_default_instance() {
    return reinterpret_cast<const KNNGraphParam*>(
               &_KNNGraphParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(KNNGraphParam* other);
  friend void swap(KNNGraphParam& a, KNNGraphParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KNNGraphParam* New() const final {
    return CreateMaybeMessage<KNNGraphParam>(nullptr);
  }

  KNNGraphParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KNNGraphParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KNNGraphParam& from);
  void MergeFrom(const KNNGraphParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KNNGraphParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.KNNGraphParam";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string distance_type = 1;
  void clear_distance_type();
  static const int kDistanceTypeFieldNumber = 1;
  const std::string& distance_type() const;
  void set_distance_type(const std::string& value);
  void set_distance_type(std::string&& value);
  void set_distance_type(const char* value);
  void set_distance_type(const char* value, size_t size);
  std::string* mutable_distance_type();
  std::string* release_distance_type();
  void set_allocated_distance_type(std::string* distance_type);

  // int32 k = 2;
  void clear_k();
  static const int kKFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 k() const;
  void set_k(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.KNNGraphParam)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr distance_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 k_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class BuildIndexRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.BuildIndexRequest) */ {
 public:
  BuildIndexRequest();
  virtual ~BuildIndexRequest();

  BuildIndexRequest(const BuildIndexRequest& from);
  BuildIndexRequest(BuildIndexRequest&& from) noexcept
    : BuildIndexRequest() {
    *this = ::std::move(from);
  }

  inline BuildIndexRequest& operator=(const BuildIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildIndexRequest& operator=(BuildIndexRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildIndexRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildIndexRequest* internal_default_instance() {
    return reinterpret_cast<const BuildIndexRequest*>(
               &_BuildIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BuildIndexRequest* other);
  friend void swap(BuildIndexRequest& a, BuildIndexRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildIndexRequest* New() const final {
    return CreateMaybeMessage<BuildIndexRequest>(nullptr);
  }

  BuildIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildIndexRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildIndexRequest& from);
  void MergeFrom(const BuildIndexRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildIndexRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.BuildIndexRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table = 1;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // string index_type = 2;
  void clear_index_type();
  static const int kIndexTypeFieldNumber = 2;
  const std::string& index_type() const;
  void set_index_type(const std::string& value);
  void set_index_type(std::string&& value);
  void set_index_type(const char* value);
  void set_index_type(const char* value, size_t size);
  std::string* mutable_index_type();
  std::string* release_index_type();
  void set_allocated_index_type(std::string* index_type);

  // .vectordb_rpc.AnnoyParam annoy_param = 3;
  bool has_annoy_param() const;
  void clear_annoy_param();
  static const int kAnnoyParamFieldNumber = 3;
  const ::vectordb_rpc::AnnoyParam& annoy_param() const;
  ::vectordb_rpc::AnnoyParam* release_annoy_param();
  ::vectordb_rpc::AnnoyParam* mutable_annoy_param();
  void set_allocated_annoy_param(::vectordb_rpc::AnnoyParam* annoy_param);

  // .vectordb_rpc.KNNGraphParam knn_graph_param = 4;
  bool has_knn_graph_param() const;
  void clear_knn_graph_param();
  static const int kKnnGraphParamFieldNumber = 4;
  const ::vectordb_rpc::KNNGraphParam& knn_graph_param() const;
  ::vectordb_rpc::KNNGraphParam* release_knn_graph_param();
  ::vectordb_rpc::KNNGraphParam* mutable_knn_graph_param();
  void set_allocated_knn_graph_param(::vectordb_rpc::KNNGraphParam* knn_graph_param);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.BuildIndexRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_type_;
  ::vectordb_rpc::AnnoyParam* annoy_param_;
  ::vectordb_rpc::KNNGraphParam* knn_graph_param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class BuildIndexReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.BuildIndexReply) */ {
 public:
  BuildIndexReply();
  virtual ~BuildIndexReply();

  BuildIndexReply(const BuildIndexReply& from);
  BuildIndexReply(BuildIndexReply&& from) noexcept
    : BuildIndexReply() {
    *this = ::std::move(from);
  }

  inline BuildIndexReply& operator=(const BuildIndexReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildIndexReply& operator=(BuildIndexReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BuildIndexReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuildIndexReply* internal_default_instance() {
    return reinterpret_cast<const BuildIndexReply*>(
               &_BuildIndexReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(BuildIndexReply* other);
  friend void swap(BuildIndexReply& a, BuildIndexReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuildIndexReply* New() const final {
    return CreateMaybeMessage<BuildIndexReply>(nullptr);
  }

  BuildIndexReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BuildIndexReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BuildIndexReply& from);
  void MergeFrom(const BuildIndexReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildIndexReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.BuildIndexReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.BuildIndexReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DistKeyRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.DistKeyRequest) */ {
 public:
  DistKeyRequest();
  virtual ~DistKeyRequest();

  DistKeyRequest(const DistKeyRequest& from);
  DistKeyRequest(DistKeyRequest&& from) noexcept
    : DistKeyRequest() {
    *this = ::std::move(from);
  }

  inline DistKeyRequest& operator=(const DistKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistKeyRequest& operator=(DistKeyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DistKeyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistKeyRequest* internal_default_instance() {
    return reinterpret_cast<const DistKeyRequest*>(
               &_DistKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DistKeyRequest* other);
  friend void swap(DistKeyRequest& a, DistKeyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistKeyRequest* New() const final {
    return CreateMaybeMessage<DistKeyRequest>(nullptr);
  }

  DistKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DistKeyRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DistKeyRequest& from);
  void MergeFrom(const DistKeyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.DistKeyRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table = 1;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // string key1 = 2;
  void clear_key1();
  static const int kKey1FieldNumber = 2;
  const std::string& key1() const;
  void set_key1(const std::string& value);
  void set_key1(std::string&& value);
  void set_key1(const char* value);
  void set_key1(const char* value, size_t size);
  std::string* mutable_key1();
  std::string* release_key1();
  void set_allocated_key1(std::string* key1);

  // string key2 = 3;
  void clear_key2();
  static const int kKey2FieldNumber = 3;
  const std::string& key2() const;
  void set_key2(const std::string& value);
  void set_key2(std::string&& value);
  void set_key2(const char* value);
  void set_key2(const char* value, size_t size);
  std::string* mutable_key2();
  std::string* release_key2();
  void set_allocated_key2(std::string* key2);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.DistKeyRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DistKeyReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.DistKeyReply) */ {
 public:
  DistKeyReply();
  virtual ~DistKeyReply();

  DistKeyReply(const DistKeyReply& from);
  DistKeyReply(DistKeyReply&& from) noexcept
    : DistKeyReply() {
    *this = ::std::move(from);
  }

  inline DistKeyReply& operator=(const DistKeyReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistKeyReply& operator=(DistKeyReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DistKeyReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistKeyReply* internal_default_instance() {
    return reinterpret_cast<const DistKeyReply*>(
               &_DistKeyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DistKeyReply* other);
  friend void swap(DistKeyReply& a, DistKeyReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistKeyReply* New() const final {
    return CreateMaybeMessage<DistKeyReply>(nullptr);
  }

  DistKeyReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DistKeyReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DistKeyReply& from);
  void MergeFrom(const DistKeyReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistKeyReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.DistKeyReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float distance = 3;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.DistKeyReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  float distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class PutVecRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.PutVecRequest) */ {
 public:
  PutVecRequest();
  virtual ~PutVecRequest();

  PutVecRequest(const PutVecRequest& from);
  PutVecRequest(PutVecRequest&& from) noexcept
    : PutVecRequest() {
    *this = ::std::move(from);
  }

  inline PutVecRequest& operator=(const PutVecRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutVecRequest& operator=(PutVecRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PutVecRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutVecRequest* internal_default_instance() {
    return reinterpret_cast<const PutVecRequest*>(
               &_PutVecRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(PutVecRequest* other);
  friend void swap(PutVecRequest& a, PutVecRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutVecRequest* New() const final {
    return CreateMaybeMessage<PutVecRequest>(nullptr);
  }

  PutVecRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutVecRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PutVecRequest& from);
  void MergeFrom(const PutVecRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutVecRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.PutVecRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table = 1;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // .vectordb_rpc.VecObj vec_obj = 2;
  bool has_vec_obj() const;
  void clear_vec_obj();
  static const int kVecObjFieldNumber = 2;
  const ::vectordb_rpc::VecObj& vec_obj() const;
  ::vectordb_rpc::VecObj* release_vec_obj();
  ::vectordb_rpc::VecObj* mutable_vec_obj();
  void set_allocated_vec_obj(::vectordb_rpc::VecObj* vec_obj);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.PutVecRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::vectordb_rpc::VecObj* vec_obj_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class PutVecReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.PutVecReply) */ {
 public:
  PutVecReply();
  virtual ~PutVecReply();

  PutVecReply(const PutVecReply& from);
  PutVecReply(PutVecReply&& from) noexcept
    : PutVecReply() {
    *this = ::std::move(from);
  }

  inline PutVecReply& operator=(const PutVecReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutVecReply& operator=(PutVecReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PutVecReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutVecReply* internal_default_instance() {
    return reinterpret_cast<const PutVecReply*>(
               &_PutVecReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(PutVecReply* other);
  friend void swap(PutVecReply& a, PutVecReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutVecReply* New() const final {
    return CreateMaybeMessage<PutVecReply>(nullptr);
  }

  PutVecReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutVecReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PutVecReply& from);
  void MergeFrom(const PutVecReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutVecReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.PutVecReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.PutVecReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class GetVecRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.GetVecRequest) */ {
 public:
  GetVecRequest();
  virtual ~GetVecRequest();

  GetVecRequest(const GetVecRequest& from);
  GetVecRequest(GetVecRequest&& from) noexcept
    : GetVecRequest() {
    *this = ::std::move(from);
  }

  inline GetVecRequest& operator=(const GetVecRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVecRequest& operator=(GetVecRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetVecRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVecRequest* internal_default_instance() {
    return reinterpret_cast<const GetVecRequest*>(
               &_GetVecRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetVecRequest* other);
  friend void swap(GetVecRequest& a, GetVecRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVecRequest* New() const final {
    return CreateMaybeMessage<GetVecRequest>(nullptr);
  }

  GetVecRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVecRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetVecRequest& from);
  void MergeFrom(const GetVecRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVecRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.GetVecRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table = 1;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.GetVecRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class GetVecReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.GetVecReply) */ {
 public:
  GetVecReply();
  virtual ~GetVecReply();

  GetVecReply(const GetVecReply& from);
  GetVecReply(GetVecReply&& from) noexcept
    : GetVecReply() {
    *this = ::std::move(from);
  }

  inline GetVecReply& operator=(const GetVecReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVecReply& operator=(GetVecReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetVecReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVecReply* internal_default_instance() {
    return reinterpret_cast<const GetVecReply*>(
               &_GetVecReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GetVecReply* other);
  friend void swap(GetVecReply& a, GetVecReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVecReply* New() const final {
    return CreateMaybeMessage<GetVecReply>(nullptr);
  }

  GetVecReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetVecReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetVecReply& from);
  void MergeFrom(const GetVecReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVecReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.GetVecReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // .vectordb_rpc.VecObj vec_obj = 3;
  bool has_vec_obj() const;
  void clear_vec_obj();
  static const int kVecObjFieldNumber = 3;
  const ::vectordb_rpc::VecObj& vec_obj() const;
  ::vectordb_rpc::VecObj* release_vec_obj();
  ::vectordb_rpc::VecObj* mutable_vec_obj();
  void set_allocated_vec_obj(::vectordb_rpc::VecObj* vec_obj);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.GetVecReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::vectordb_rpc::VecObj* vec_obj_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Replica :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.Replica) */ {
 public:
  Replica();
  virtual ~Replica();

  Replica(const Replica& from);
  Replica(Replica&& from) noexcept
    : Replica() {
    *this = ::std::move(from);
  }

  inline Replica& operator=(const Replica& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replica& operator=(Replica&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Replica& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Replica* internal_default_instance() {
    return reinterpret_cast<const Replica*>(
               &_Replica_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Replica* other);
  friend void swap(Replica& a, Replica& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Replica* New() const final {
    return CreateMaybeMessage<Replica>(nullptr);
  }

  Replica* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Replica>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Replica& from);
  void MergeFrom(const Replica& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Replica* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.Replica";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string table_name = 3;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // string partition_name = 4;
  void clear_partition_name();
  static const int kPartitionNameFieldNumber = 4;
  const std::string& partition_name() const;
  void set_partition_name(const std::string& value);
  void set_partition_name(std::string&& value);
  void set_partition_name(const char* value);
  void set_partition_name(const char* value, size_t size);
  std::string* mutable_partition_name();
  std::string* release_partition_name();
  void set_allocated_partition_name(std::string* partition_name);

  // string address = 5;
  void clear_address();
  static const int kAddressFieldNumber = 5;
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);

  // string path = 6;
  void clear_path();
  static const int kPathFieldNumber = 6;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.Replica)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Partition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.Partition) */ {
 public:
  Partition();
  virtual ~Partition();

  Partition(const Partition& from);
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition& operator=(Partition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Partition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Partition* other);
  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Partition* New() const final {
    return CreateMaybeMessage<Partition>(nullptr);
  }

  Partition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Partition& from);
  void MergeFrom(const Partition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.Partition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vectordb_rpc.Replica replicas = 6;
  int replicas_size() const;
  void clear_replicas();
  static const int kReplicasFieldNumber = 6;
  ::vectordb_rpc::Replica* mutable_replicas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Replica >*
      mutable_replicas();
  const ::vectordb_rpc::Replica& replicas(int index) const;
  ::vectordb_rpc::Replica* add_replicas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Replica >&
      replicas() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string table_name = 3;
  void clear_table_name();
  static const int kTableNameFieldNumber = 3;
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // string path = 5;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 replica_num = 4;
  void clear_replica_num();
  static const int kReplicaNumFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.Partition)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Replica > replicas_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Index :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.Index) */ {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  inline Index& operator=(Index&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Index& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Index* other);
  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const final {
    return CreateMaybeMessage<Index>(nullptr);
  }

  Index* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.Index";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string index_name = 1;
  void clear_index_name();
  static const int kIndexNameFieldNumber = 1;
  const std::string& index_name() const;
  void set_index_name(const std::string& value);
  void set_index_name(std::string&& value);
  void set_index_name(const char* value);
  void set_index_name(const char* value, size_t size);
  std::string* mutable_index_name();
  std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);

  // string index_type = 2;
  void clear_index_type();
  static const int kIndexTypeFieldNumber = 2;
  const std::string& index_type() const;
  void set_index_type(const std::string& value);
  void set_index_type(std::string&& value);
  void set_index_type(const char* value);
  void set_index_type(const char* value, size_t size);
  std::string* mutable_index_type();
  std::string* release_index_type();
  void set_allocated_index_type(std::string* index_type);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.Index)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class Table :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.Table) */ {
 public:
  Table();
  virtual ~Table();

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Table& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(Table* other);
  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Table* New() const final {
    return CreateMaybeMessage<Table>(nullptr);
  }

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Table& from);
  void MergeFrom(const Table& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.Table";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vectordb_rpc.Partition partitions = 6;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 6;
  ::vectordb_rpc::Partition* mutable_partitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Partition >*
      mutable_partitions();
  const ::vectordb_rpc::Partition& partitions(int index) const;
  ::vectordb_rpc::Partition* add_partitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Partition >&
      partitions() const;

  // repeated .vectordb_rpc.Index indices = 7;
  int indices_size() const;
  void clear_indices();
  static const int kIndicesFieldNumber = 7;
  ::vectordb_rpc::Index* mutable_indices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Index >*
      mutable_indices();
  const ::vectordb_rpc::Index& indices(int index) const;
  ::vectordb_rpc::Index* add_indices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Index >&
      indices() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string engine_type = 4;
  void clear_engine_type();
  static const int kEngineTypeFieldNumber = 4;
  const std::string& engine_type() const;
  void set_engine_type(const std::string& value);
  void set_engine_type(std::string&& value);
  void set_engine_type(const char* value);
  void set_engine_type(const char* value, size_t size);
  std::string* mutable_engine_type();
  std::string* release_engine_type();
  void set_allocated_engine_type(std::string* engine_type);

  // string path = 5;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // int32 partition_num = 2;
  void clear_partition_num();
  static const int kPartitionNumFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 partition_num() const;
  void set_partition_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 replica_num = 3;
  void clear_replica_num();
  static const int kReplicaNumFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 dim = 8;
  void clear_dim();
  static const int kDimFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::int32 dim() const;
  void set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.Table)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Partition > partitions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Index > indices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 partition_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 dim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class TableNames :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.TableNames) */ {
 public:
  TableNames();
  virtual ~TableNames();

  TableNames(const TableNames& from);
  TableNames(TableNames&& from) noexcept
    : TableNames() {
    *this = ::std::move(from);
  }

  inline TableNames& operator=(const TableNames& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableNames& operator=(TableNames&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableNames& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableNames* internal_default_instance() {
    return reinterpret_cast<const TableNames*>(
               &_TableNames_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(TableNames* other);
  friend void swap(TableNames& a, TableNames& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableNames* New() const final {
    return CreateMaybeMessage<TableNames>(nullptr);
  }

  TableNames* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableNames>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableNames& from);
  void MergeFrom(const TableNames& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableNames* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.TableNames";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string table_names = 1;
  int table_names_size() const;
  void clear_table_names();
  static const int kTableNamesFieldNumber = 1;
  const std::string& table_names(int index) const;
  std::string* mutable_table_names(int index);
  void set_table_names(int index, const std::string& value);
  void set_table_names(int index, std::string&& value);
  void set_table_names(int index, const char* value);
  void set_table_names(int index, const char* value, size_t size);
  std::string* add_table_names();
  void add_table_names(const std::string& value);
  void add_table_names(std::string&& value);
  void add_table_names(const char* value);
  void add_table_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& table_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_table_names();

  // @@protoc_insertion_point(class_scope:vectordb_rpc.TableNames)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> table_names_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class PingRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.PingRequest) */ {
 public:
  PingRequest();
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(PingRequest* other);
  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return CreateMaybeMessage<PingRequest>(nullptr);
  }

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.PingRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.PingRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class PingReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.PingReply) */ {
 public:
  PingReply();
  virtual ~PingReply();

  PingReply(const PingReply& from);
  PingReply(PingReply&& from) noexcept
    : PingReply() {
    *this = ::std::move(from);
  }

  inline PingReply& operator=(const PingReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingReply& operator=(PingReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PingReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingReply* internal_default_instance() {
    return reinterpret_cast<const PingReply*>(
               &_PingReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(PingReply* other);
  friend void swap(PingReply& a, PingReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingReply* New() const final {
    return CreateMaybeMessage<PingReply>(nullptr);
  }

  PingReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PingReply& from);
  void MergeFrom(const PingReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.PingReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.PingReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CreateTableRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.CreateTableRequest) */ {
 public:
  CreateTableRequest();
  virtual ~CreateTableRequest();

  CreateTableRequest(const CreateTableRequest& from);
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTableRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CreateTableRequest* other);
  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTableRequest* New() const final {
    return CreateMaybeMessage<CreateTableRequest>(nullptr);
  }

  CreateTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTableRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTableRequest& from);
  void MergeFrom(const CreateTableRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.CreateTableRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string table_name = 1;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // int32 partition_num = 2;
  void clear_partition_num();
  static const int kPartitionNumFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 partition_num() const;
  void set_partition_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 replica_num = 3;
  void clear_replica_num();
  static const int kReplicaNumFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 dim = 4;
  void clear_dim();
  static const int kDimFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 dim() const;
  void set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.CreateTableRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 partition_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 dim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class CreateTableReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.CreateTableReply) */ {
 public:
  CreateTableReply();
  virtual ~CreateTableReply();

  CreateTableReply(const CreateTableReply& from);
  CreateTableReply(CreateTableReply&& from) noexcept
    : CreateTableReply() {
    *this = ::std::move(from);
  }

  inline CreateTableReply& operator=(const CreateTableReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableReply& operator=(CreateTableReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateTableReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTableReply* internal_default_instance() {
    return reinterpret_cast<const CreateTableReply*>(
               &_CreateTableReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CreateTableReply* other);
  friend void swap(CreateTableReply& a, CreateTableReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTableReply* New() const final {
    return CreateMaybeMessage<CreateTableReply>(nullptr);
  }

  CreateTableReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTableReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateTableReply& from);
  void MergeFrom(const CreateTableReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.CreateTableReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.CreateTableReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class ShowTablesRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.ShowTablesRequest) */ {
 public:
  ShowTablesRequest();
  virtual ~ShowTablesRequest();

  ShowTablesRequest(const ShowTablesRequest& from);
  ShowTablesRequest(ShowTablesRequest&& from) noexcept
    : ShowTablesRequest() {
    *this = ::std::move(from);
  }

  inline ShowTablesRequest& operator=(const ShowTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowTablesRequest& operator=(ShowTablesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShowTablesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShowTablesRequest* internal_default_instance() {
    return reinterpret_cast<const ShowTablesRequest*>(
               &_ShowTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ShowTablesRequest* other);
  friend void swap(ShowTablesRequest& a, ShowTablesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShowTablesRequest* New() const final {
    return CreateMaybeMessage<ShowTablesRequest>(nullptr);
  }

  ShowTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowTablesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShowTablesRequest& from);
  void MergeFrom(const ShowTablesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.ShowTablesRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vectordb_rpc.ShowTablesRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class ShowTablesReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.ShowTablesReply) */ {
 public:
  ShowTablesReply();
  virtual ~ShowTablesReply();

  ShowTablesReply(const ShowTablesReply& from);
  ShowTablesReply(ShowTablesReply&& from) noexcept
    : ShowTablesReply() {
    *this = ::std::move(from);
  }

  inline ShowTablesReply& operator=(const ShowTablesReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowTablesReply& operator=(ShowTablesReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShowTablesReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShowTablesReply* internal_default_instance() {
    return reinterpret_cast<const ShowTablesReply*>(
               &_ShowTablesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ShowTablesReply* other);
  friend void swap(ShowTablesReply& a, ShowTablesReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShowTablesReply* New() const final {
    return CreateMaybeMessage<ShowTablesReply>(nullptr);
  }

  ShowTablesReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowTablesReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShowTablesReply& from);
  void MergeFrom(const ShowTablesReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowTablesReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.ShowTablesReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tables = 1;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 1;
  const std::string& tables(int index) const;
  std::string* mutable_tables(int index);
  void set_tables(int index, const std::string& value);
  void set_tables(int index, std::string&& value);
  void set_tables(int index, const char* value);
  void set_tables(int index, const char* value, size_t size);
  std::string* add_tables();
  void add_tables(const std::string& value);
  void add_tables(std::string&& value);
  void add_tables(const char* value);
  void add_tables(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tables();

  // @@protoc_insertion_point(class_scope:vectordb_rpc.ShowTablesReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tables_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DescribeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.DescribeRequest) */ {
 public:
  DescribeRequest();
  virtual ~DescribeRequest();

  DescribeRequest(const DescribeRequest& from);
  DescribeRequest(DescribeRequest&& from) noexcept
    : DescribeRequest() {
    *this = ::std::move(from);
  }

  inline DescribeRequest& operator=(const DescribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeRequest& operator=(DescribeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DescribeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DescribeRequest* internal_default_instance() {
    return reinterpret_cast<const DescribeRequest*>(
               &_DescribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(DescribeRequest* other);
  friend void swap(DescribeRequest& a, DescribeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DescribeRequest* New() const final {
    return CreateMaybeMessage<DescribeRequest>(nullptr);
  }

  DescribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DescribeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DescribeRequest& from);
  void MergeFrom(const DescribeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.DescribeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.DescribeRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class DescribeReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.DescribeReply) */ {
 public:
  DescribeReply();
  virtual ~DescribeReply();

  DescribeReply(const DescribeReply& from);
  DescribeReply(DescribeReply&& from) noexcept
    : DescribeReply() {
    *this = ::std::move(from);
  }

  inline DescribeReply& operator=(const DescribeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeReply& operator=(DescribeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DescribeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DescribeReply* internal_default_instance() {
    return reinterpret_cast<const DescribeReply*>(
               &_DescribeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(DescribeReply* other);
  friend void swap(DescribeReply& a, DescribeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DescribeReply* New() const final {
    return CreateMaybeMessage<DescribeReply>(nullptr);
  }

  DescribeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DescribeReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DescribeReply& from);
  void MergeFrom(const DescribeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.DescribeReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // .vectordb_rpc.Table table = 4;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 4;
  const ::vectordb_rpc::Table& table() const;
  ::vectordb_rpc::Table* release_table();
  ::vectordb_rpc::Table* mutable_table();
  void set_allocated_table(::vectordb_rpc::Table* table);

  // .vectordb_rpc.Partition partition = 6;
  bool has_partition() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 6;
  const ::vectordb_rpc::Partition& partition() const;
  ::vectordb_rpc::Partition* release_partition();
  ::vectordb_rpc::Partition* mutable_partition();
  void set_allocated_partition(::vectordb_rpc::Partition* partition);

  // .vectordb_rpc.Replica replica = 8;
  bool has_replica() const;
  void clear_replica();
  static const int kReplicaFieldNumber = 8;
  const ::vectordb_rpc::Replica& replica() const;
  ::vectordb_rpc::Replica* release_replica();
  ::vectordb_rpc::Replica* mutable_replica();
  void set_allocated_replica(::vectordb_rpc::Replica* replica);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool describe_table = 3;
  void clear_describe_table();
  static const int kDescribeTableFieldNumber = 3;
  bool describe_table() const;
  void set_describe_table(bool value);

  // bool describe_partition = 5;
  void clear_describe_partition();
  static const int kDescribePartitionFieldNumber = 5;
  bool describe_partition() const;
  void set_describe_partition(bool value);

  // bool describe_replica = 7;
  void clear_describe_replica();
  static const int kDescribeReplicaFieldNumber = 7;
  bool describe_replica() const;
  void set_describe_replica(bool value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.DescribeReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::vectordb_rpc::Table* table_;
  ::vectordb_rpc::Partition* partition_;
  ::vectordb_rpc::Replica* replica_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  bool describe_table_;
  bool describe_partition_;
  bool describe_replica_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class InfoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.InfoRequest) */ {
 public:
  InfoRequest();
  virtual ~InfoRequest();

  InfoRequest(const InfoRequest& from);
  InfoRequest(InfoRequest&& from) noexcept
    : InfoRequest() {
    *this = ::std::move(from);
  }

  inline InfoRequest& operator=(const InfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoRequest& operator=(InfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfoRequest* internal_default_instance() {
    return reinterpret_cast<const InfoRequest*>(
               &_InfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(InfoRequest* other);
  friend void swap(InfoRequest& a, InfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InfoRequest* New() const final {
    return CreateMaybeMessage<InfoRequest>(nullptr);
  }

  InfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InfoRequest& from);
  void MergeFrom(const InfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.InfoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vectordb_rpc.InfoRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class InfoReply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.InfoReply) */ {
 public:
  InfoReply();
  virtual ~InfoReply();

  InfoReply(const InfoReply& from);
  InfoReply(InfoReply&& from) noexcept
    : InfoReply() {
    *this = ::std::move(from);
  }

  inline InfoReply& operator=(const InfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoReply& operator=(InfoReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InfoReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfoReply* internal_default_instance() {
    return reinterpret_cast<const InfoReply*>(
               &_InfoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(InfoReply* other);
  friend void swap(InfoReply& a, InfoReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InfoReply* New() const final {
    return CreateMaybeMessage<InfoReply>(nullptr);
  }

  InfoReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InfoReply& from);
  void MergeFrom(const InfoReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.InfoReply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 1;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.InfoReply)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// -------------------------------------------------------------------

class VEngineMeta :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vectordb_rpc.VEngineMeta) */ {
 public:
  VEngineMeta();
  virtual ~VEngineMeta();

  VEngineMeta(const VEngineMeta& from);
  VEngineMeta(VEngineMeta&& from) noexcept
    : VEngineMeta() {
    *this = ::std::move(from);
  }

  inline VEngineMeta& operator=(const VEngineMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline VEngineMeta& operator=(VEngineMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VEngineMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VEngineMeta* internal_default_instance() {
    return reinterpret_cast<const VEngineMeta*>(
               &_VEngineMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(VEngineMeta* other);
  friend void swap(VEngineMeta& a, VEngineMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VEngineMeta* New() const final {
    return CreateMaybeMessage<VEngineMeta>(nullptr);
  }

  VEngineMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VEngineMeta>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VEngineMeta& from);
  void MergeFrom(const VEngineMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VEngineMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vectordb_rpc.VEngineMeta";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vectordb_5frpc_2eproto);
    return ::descriptor_table_vectordb_5frpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string index_names = 3;
  int index_names_size() const;
  void clear_index_names();
  static const int kIndexNamesFieldNumber = 3;
  const std::string& index_names(int index) const;
  std::string* mutable_index_names(int index);
  void set_index_names(int index, const std::string& value);
  void set_index_names(int index, std::string&& value);
  void set_index_names(int index, const char* value);
  void set_index_names(int index, const char* value, size_t size);
  std::string* add_index_names();
  void add_index_names(const std::string& value);
  void add_index_names(std::string&& value);
  void add_index_names(const char* value);
  void add_index_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& index_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_index_names();

  // string replica_name = 2;
  void clear_replica_name();
  static const int kReplicaNameFieldNumber = 2;
  const std::string& replica_name() const;
  void set_replica_name(const std::string& value);
  void set_replica_name(std::string&& value);
  void set_replica_name(const char* value);
  void set_replica_name(const char* value, size_t size);
  std::string* mutable_replica_name();
  std::string* release_replica_name();
  void set_allocated_replica_name(std::string* replica_name);

  // int32 dim = 1;
  void clear_dim();
  static const int kDimFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 dim() const;
  void set_dim(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:vectordb_rpc.VEngineMeta)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> index_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replica_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 dim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vectordb_5frpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KNNKey

// string key = 1;
inline void KNNKey::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KNNKey::key() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KNNKey.key)
  return key_.GetNoArena();
}
inline void KNNKey::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.KNNKey.key)
}
inline void KNNKey::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.KNNKey.key)
}
inline void KNNKey::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.KNNKey.key)
}
inline void KNNKey::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.KNNKey.key)
}
inline std::string* KNNKey::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.KNNKey.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KNNKey::release_key() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.KNNKey.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KNNKey::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.KNNKey.key)
}

// int32 sequence = 2;
inline void KNNKey::clear_sequence() {
  sequence_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KNNKey::sequence() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KNNKey.sequence)
  return sequence_;
}
inline void KNNKey::set_sequence(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.KNNKey.sequence)
}

// -------------------------------------------------------------------

// KNNValue

// string key = 1;
inline void KNNValue::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KNNValue::key() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KNNValue.key)
  return key_.GetNoArena();
}
inline void KNNValue::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.KNNValue.key)
}
inline void KNNValue::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.KNNValue.key)
}
inline void KNNValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.KNNValue.key)
}
inline void KNNValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.KNNValue.key)
}
inline std::string* KNNValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.KNNValue.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KNNValue::release_key() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.KNNValue.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KNNValue::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.KNNValue.key)
}

// float distance = 2;
inline void KNNValue::clear_distance() {
  distance_ = 0;
}
inline float KNNValue::distance() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KNNValue.distance)
  return distance_;
}
inline void KNNValue::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.KNNValue.distance)
}

// -------------------------------------------------------------------

// Int32

// int32 data = 1;
inline void Int32::clear_data() {
  data_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Int32::data() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Int32.data)
  return data_;
}
inline void Int32::set_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  data_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Int32.data)
}

// -------------------------------------------------------------------

// GetKNNRequest

// string table = 1;
inline void GetKNNRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKNNRequest::table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNRequest.table)
  return table_.GetNoArena();
}
inline void GetKNNRequest::set_table(const std::string& value) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetKNNRequest.table)
}
inline void GetKNNRequest::set_table(std::string&& value) {
  
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetKNNRequest.table)
}
inline void GetKNNRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetKNNRequest.table)
}
inline void GetKNNRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetKNNRequest.table)
}
inline std::string* GetKNNRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetKNNRequest.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKNNRequest::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetKNNRequest.table)
  
  return table_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKNNRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetKNNRequest.table)
}

// string key = 2;
inline void GetKNNRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKNNRequest::key() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNRequest.key)
  return key_.GetNoArena();
}
inline void GetKNNRequest::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetKNNRequest.key)
}
inline void GetKNNRequest::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetKNNRequest.key)
}
inline void GetKNNRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetKNNRequest.key)
}
inline void GetKNNRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetKNNRequest.key)
}
inline std::string* GetKNNRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetKNNRequest.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKNNRequest::release_key() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetKNNRequest.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKNNRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetKNNRequest.key)
}

// int32 limit = 3;
inline void GetKNNRequest::clear_limit() {
  limit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetKNNRequest::limit() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNRequest.limit)
  return limit_;
}
inline void GetKNNRequest::set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetKNNRequest.limit)
}

// string index_name = 4;
inline void GetKNNRequest::clear_index_name() {
  index_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKNNRequest::index_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNRequest.index_name)
  return index_name_.GetNoArena();
}
inline void GetKNNRequest::set_index_name(const std::string& value) {
  
  index_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetKNNRequest.index_name)
}
inline void GetKNNRequest::set_index_name(std::string&& value) {
  
  index_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetKNNRequest.index_name)
}
inline void GetKNNRequest::set_index_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  index_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetKNNRequest.index_name)
}
inline void GetKNNRequest::set_index_name(const char* value, size_t size) {
  
  index_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetKNNRequest.index_name)
}
inline std::string* GetKNNRequest::mutable_index_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetKNNRequest.index_name)
  return index_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKNNRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetKNNRequest.index_name)
  
  return index_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKNNRequest::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  index_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetKNNRequest.index_name)
}

// -------------------------------------------------------------------

// VecDt

// string key = 1;
inline void VecDt::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecDt::key() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecDt.key)
  return key_.GetNoArena();
}
inline void VecDt::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecDt.key)
}
inline void VecDt::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecDt.key)
}
inline void VecDt::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecDt.key)
}
inline void VecDt::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecDt.key)
}
inline std::string* VecDt::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecDt.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecDt::release_key() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecDt.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecDt::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecDt.key)
}

// float distance = 2;
inline void VecDt::clear_distance() {
  distance_ = 0;
}
inline float VecDt::distance() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecDt.distance)
  return distance_;
}
inline void VecDt::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecDt.distance)
}

// string attach_value1 = 3;
inline void VecDt::clear_attach_value1() {
  attach_value1_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecDt::attach_value1() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecDt.attach_value1)
  return attach_value1_.GetNoArena();
}
inline void VecDt::set_attach_value1(const std::string& value) {
  
  attach_value1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecDt.attach_value1)
}
inline void VecDt::set_attach_value1(std::string&& value) {
  
  attach_value1_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecDt.attach_value1)
}
inline void VecDt::set_attach_value1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attach_value1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecDt.attach_value1)
}
inline void VecDt::set_attach_value1(const char* value, size_t size) {
  
  attach_value1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecDt.attach_value1)
}
inline std::string* VecDt::mutable_attach_value1() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecDt.attach_value1)
  return attach_value1_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecDt::release_attach_value1() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecDt.attach_value1)
  
  return attach_value1_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecDt::set_allocated_attach_value1(std::string* attach_value1) {
  if (attach_value1 != nullptr) {
    
  } else {
    
  }
  attach_value1_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_value1);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecDt.attach_value1)
}

// string attach_value2 = 4;
inline void VecDt::clear_attach_value2() {
  attach_value2_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecDt::attach_value2() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecDt.attach_value2)
  return attach_value2_.GetNoArena();
}
inline void VecDt::set_attach_value2(const std::string& value) {
  
  attach_value2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecDt.attach_value2)
}
inline void VecDt::set_attach_value2(std::string&& value) {
  
  attach_value2_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecDt.attach_value2)
}
inline void VecDt::set_attach_value2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attach_value2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecDt.attach_value2)
}
inline void VecDt::set_attach_value2(const char* value, size_t size) {
  
  attach_value2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecDt.attach_value2)
}
inline std::string* VecDt::mutable_attach_value2() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecDt.attach_value2)
  return attach_value2_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecDt::release_attach_value2() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecDt.attach_value2)
  
  return attach_value2_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecDt::set_allocated_attach_value2(std::string* attach_value2) {
  if (attach_value2 != nullptr) {
    
  } else {
    
  }
  attach_value2_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_value2);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecDt.attach_value2)
}

// string attach_value3 = 5;
inline void VecDt::clear_attach_value3() {
  attach_value3_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecDt::attach_value3() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecDt.attach_value3)
  return attach_value3_.GetNoArena();
}
inline void VecDt::set_attach_value3(const std::string& value) {
  
  attach_value3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecDt.attach_value3)
}
inline void VecDt::set_attach_value3(std::string&& value) {
  
  attach_value3_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecDt.attach_value3)
}
inline void VecDt::set_attach_value3(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attach_value3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecDt.attach_value3)
}
inline void VecDt::set_attach_value3(const char* value, size_t size) {
  
  attach_value3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecDt.attach_value3)
}
inline std::string* VecDt::mutable_attach_value3() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecDt.attach_value3)
  return attach_value3_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecDt::release_attach_value3() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecDt.attach_value3)
  
  return attach_value3_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecDt::set_allocated_attach_value3(std::string* attach_value3) {
  if (attach_value3 != nullptr) {
    
  } else {
    
  }
  attach_value3_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_value3);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecDt.attach_value3)
}

// -------------------------------------------------------------------

// GetKNNReply

// int32 code = 1;
inline void GetKNNReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetKNNReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNReply.code)
  return code_;
}
inline void GetKNNReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetKNNReply.code)
}

// string msg = 2;
inline void GetKNNReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetKNNReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNReply.msg)
  return msg_.GetNoArena();
}
inline void GetKNNReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetKNNReply.msg)
}
inline void GetKNNReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetKNNReply.msg)
}
inline void GetKNNReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetKNNReply.msg)
}
inline void GetKNNReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetKNNReply.msg)
}
inline std::string* GetKNNReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetKNNReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetKNNReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetKNNReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetKNNReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetKNNReply.msg)
}

// repeated .vectordb_rpc.VecDt vecdts = 3;
inline int GetKNNReply::vecdts_size() const {
  return vecdts_.size();
}
inline void GetKNNReply::clear_vecdts() {
  vecdts_.Clear();
}
inline ::vectordb_rpc::VecDt* GetKNNReply::mutable_vecdts(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetKNNReply.vecdts)
  return vecdts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::VecDt >*
GetKNNReply::mutable_vecdts() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.GetKNNReply.vecdts)
  return &vecdts_;
}
inline const ::vectordb_rpc::VecDt& GetKNNReply::vecdts(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetKNNReply.vecdts)
  return vecdts_.Get(index);
}
inline ::vectordb_rpc::VecDt* GetKNNReply::add_vecdts() {
  // @@protoc_insertion_point(field_add:vectordb_rpc.GetKNNReply.vecdts)
  return vecdts_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::VecDt >&
GetKNNReply::vecdts() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.GetKNNReply.vecdts)
  return vecdts_;
}

// -------------------------------------------------------------------

// VecObj

// string key = 1;
inline void VecObj::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecObj::key() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecObj.key)
  return key_.GetNoArena();
}
inline void VecObj::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecObj.key)
}
inline void VecObj::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecObj.key)
}
inline void VecObj::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecObj.key)
}
inline void VecObj::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecObj.key)
}
inline std::string* VecObj::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecObj.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecObj::release_key() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecObj.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecObj::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecObj.key)
}

// .vectordb_rpc.Vec vec = 2;
inline bool VecObj::has_vec() const {
  return this != internal_default_instance() && vec_ != nullptr;
}
inline void VecObj::clear_vec() {
  if (GetArenaNoVirtual() == nullptr && vec_ != nullptr) {
    delete vec_;
  }
  vec_ = nullptr;
}
inline const ::vectordb_rpc::Vec& VecObj::vec() const {
  const ::vectordb_rpc::Vec* p = vec_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecObj.vec)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::Vec*>(
      &::vectordb_rpc::_Vec_default_instance_);
}
inline ::vectordb_rpc::Vec* VecObj::release_vec() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecObj.vec)
  
  ::vectordb_rpc::Vec* temp = vec_;
  vec_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::Vec* VecObj::mutable_vec() {
  
  if (vec_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::Vec>(GetArenaNoVirtual());
    vec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecObj.vec)
  return vec_;
}
inline void VecObj::set_allocated_vec(::vectordb_rpc::Vec* vec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vec_;
  }
  if (vec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec, submessage_arena);
    }
    
  } else {
    
  }
  vec_ = vec;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecObj.vec)
}

// string attach_value1 = 3;
inline void VecObj::clear_attach_value1() {
  attach_value1_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecObj::attach_value1() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecObj.attach_value1)
  return attach_value1_.GetNoArena();
}
inline void VecObj::set_attach_value1(const std::string& value) {
  
  attach_value1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecObj.attach_value1)
}
inline void VecObj::set_attach_value1(std::string&& value) {
  
  attach_value1_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecObj.attach_value1)
}
inline void VecObj::set_attach_value1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attach_value1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecObj.attach_value1)
}
inline void VecObj::set_attach_value1(const char* value, size_t size) {
  
  attach_value1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecObj.attach_value1)
}
inline std::string* VecObj::mutable_attach_value1() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecObj.attach_value1)
  return attach_value1_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecObj::release_attach_value1() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecObj.attach_value1)
  
  return attach_value1_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecObj::set_allocated_attach_value1(std::string* attach_value1) {
  if (attach_value1 != nullptr) {
    
  } else {
    
  }
  attach_value1_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_value1);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecObj.attach_value1)
}

// string attach_value2 = 4;
inline void VecObj::clear_attach_value2() {
  attach_value2_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecObj::attach_value2() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecObj.attach_value2)
  return attach_value2_.GetNoArena();
}
inline void VecObj::set_attach_value2(const std::string& value) {
  
  attach_value2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecObj.attach_value2)
}
inline void VecObj::set_attach_value2(std::string&& value) {
  
  attach_value2_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecObj.attach_value2)
}
inline void VecObj::set_attach_value2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attach_value2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecObj.attach_value2)
}
inline void VecObj::set_attach_value2(const char* value, size_t size) {
  
  attach_value2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecObj.attach_value2)
}
inline std::string* VecObj::mutable_attach_value2() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecObj.attach_value2)
  return attach_value2_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecObj::release_attach_value2() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecObj.attach_value2)
  
  return attach_value2_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecObj::set_allocated_attach_value2(std::string* attach_value2) {
  if (attach_value2 != nullptr) {
    
  } else {
    
  }
  attach_value2_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_value2);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecObj.attach_value2)
}

// string attach_value3 = 5;
inline void VecObj::clear_attach_value3() {
  attach_value3_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VecObj::attach_value3() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VecObj.attach_value3)
  return attach_value3_.GetNoArena();
}
inline void VecObj::set_attach_value3(const std::string& value) {
  
  attach_value3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VecObj.attach_value3)
}
inline void VecObj::set_attach_value3(std::string&& value) {
  
  attach_value3_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VecObj.attach_value3)
}
inline void VecObj::set_attach_value3(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attach_value3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VecObj.attach_value3)
}
inline void VecObj::set_attach_value3(const char* value, size_t size) {
  
  attach_value3_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VecObj.attach_value3)
}
inline std::string* VecObj::mutable_attach_value3() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VecObj.attach_value3)
  return attach_value3_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VecObj::release_attach_value3() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VecObj.attach_value3)
  
  return attach_value3_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VecObj::set_allocated_attach_value3(std::string* attach_value3) {
  if (attach_value3 != nullptr) {
    
  } else {
    
  }
  attach_value3_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attach_value3);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VecObj.attach_value3)
}

// -------------------------------------------------------------------

// Vec

// repeated float data = 1;
inline int Vec::data_size() const {
  return data_.size();
}
inline void Vec::clear_data() {
  data_.Clear();
}
inline float Vec::data(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Vec.data)
  return data_.Get(index);
}
inline void Vec::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Vec.data)
}
inline void Vec::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:vectordb_rpc.Vec.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Vec::data() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.Vec.data)
  return data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Vec::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.Vec.data)
  return &data_;
}

// -------------------------------------------------------------------

// KeysRequest

// string table = 1;
inline void KeysRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeysRequest::table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KeysRequest.table)
  return table_.GetNoArena();
}
inline void KeysRequest::set_table(const std::string& value) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.KeysRequest.table)
}
inline void KeysRequest::set_table(std::string&& value) {
  
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.KeysRequest.table)
}
inline void KeysRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.KeysRequest.table)
}
inline void KeysRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.KeysRequest.table)
}
inline std::string* KeysRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.KeysRequest.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeysRequest::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.KeysRequest.table)
  
  return table_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeysRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.KeysRequest.table)
}

// -------------------------------------------------------------------

// KeysReply

// int32 code = 1;
inline void KeysReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KeysReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KeysReply.code)
  return code_;
}
inline void KeysReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.KeysReply.code)
}

// string msg = 2;
inline void KeysReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KeysReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KeysReply.msg)
  return msg_.GetNoArena();
}
inline void KeysReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.KeysReply.msg)
}
inline void KeysReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.KeysReply.msg)
}
inline void KeysReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.KeysReply.msg)
}
inline void KeysReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.KeysReply.msg)
}
inline std::string* KeysReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.KeysReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KeysReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.KeysReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KeysReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.KeysReply.msg)
}

// repeated string keys = 3;
inline int KeysReply::keys_size() const {
  return keys_.size();
}
inline void KeysReply::clear_keys() {
  keys_.Clear();
}
inline const std::string& KeysReply::keys(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KeysReply.keys)
  return keys_.Get(index);
}
inline std::string* KeysReply::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.KeysReply.keys)
  return keys_.Mutable(index);
}
inline void KeysReply::set_keys(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.KeysReply.keys)
  keys_.Mutable(index)->assign(value);
}
inline void KeysReply::set_keys(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.KeysReply.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
inline void KeysReply::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.KeysReply.keys)
}
inline void KeysReply::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.KeysReply.keys)
}
inline std::string* KeysReply::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:vectordb_rpc.KeysReply.keys)
  return keys_.Add();
}
inline void KeysReply::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vectordb_rpc.KeysReply.keys)
}
inline void KeysReply::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vectordb_rpc.KeysReply.keys)
}
inline void KeysReply::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vectordb_rpc.KeysReply.keys)
}
inline void KeysReply::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vectordb_rpc.KeysReply.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
KeysReply::keys() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.KeysReply.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
KeysReply::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.KeysReply.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// AnnoyParam

// string distance_type = 1;
inline void AnnoyParam::clear_distance_type() {
  distance_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AnnoyParam::distance_type() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.AnnoyParam.distance_type)
  return distance_type_.GetNoArena();
}
inline void AnnoyParam::set_distance_type(const std::string& value) {
  
  distance_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.AnnoyParam.distance_type)
}
inline void AnnoyParam::set_distance_type(std::string&& value) {
  
  distance_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.AnnoyParam.distance_type)
}
inline void AnnoyParam::set_distance_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  distance_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.AnnoyParam.distance_type)
}
inline void AnnoyParam::set_distance_type(const char* value, size_t size) {
  
  distance_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.AnnoyParam.distance_type)
}
inline std::string* AnnoyParam::mutable_distance_type() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.AnnoyParam.distance_type)
  return distance_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AnnoyParam::release_distance_type() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.AnnoyParam.distance_type)
  
  return distance_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AnnoyParam::set_allocated_distance_type(std::string* distance_type) {
  if (distance_type != nullptr) {
    
  } else {
    
  }
  distance_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), distance_type);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.AnnoyParam.distance_type)
}

// -------------------------------------------------------------------

// KNNGraphParam

// string distance_type = 1;
inline void KNNGraphParam::clear_distance_type() {
  distance_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& KNNGraphParam::distance_type() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KNNGraphParam.distance_type)
  return distance_type_.GetNoArena();
}
inline void KNNGraphParam::set_distance_type(const std::string& value) {
  
  distance_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.KNNGraphParam.distance_type)
}
inline void KNNGraphParam::set_distance_type(std::string&& value) {
  
  distance_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.KNNGraphParam.distance_type)
}
inline void KNNGraphParam::set_distance_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  distance_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.KNNGraphParam.distance_type)
}
inline void KNNGraphParam::set_distance_type(const char* value, size_t size) {
  
  distance_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.KNNGraphParam.distance_type)
}
inline std::string* KNNGraphParam::mutable_distance_type() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.KNNGraphParam.distance_type)
  return distance_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* KNNGraphParam::release_distance_type() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.KNNGraphParam.distance_type)
  
  return distance_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void KNNGraphParam::set_allocated_distance_type(std::string* distance_type) {
  if (distance_type != nullptr) {
    
  } else {
    
  }
  distance_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), distance_type);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.KNNGraphParam.distance_type)
}

// int32 k = 2;
inline void KNNGraphParam::clear_k() {
  k_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KNNGraphParam::k() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.KNNGraphParam.k)
  return k_;
}
inline void KNNGraphParam::set_k(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.KNNGraphParam.k)
}

// -------------------------------------------------------------------

// BuildIndexRequest

// string table = 1;
inline void BuildIndexRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildIndexRequest::table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.BuildIndexRequest.table)
  return table_.GetNoArena();
}
inline void BuildIndexRequest::set_table(const std::string& value) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.BuildIndexRequest.table)
}
inline void BuildIndexRequest::set_table(std::string&& value) {
  
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.BuildIndexRequest.table)
}
inline void BuildIndexRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.BuildIndexRequest.table)
}
inline void BuildIndexRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.BuildIndexRequest.table)
}
inline std::string* BuildIndexRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.BuildIndexRequest.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildIndexRequest::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.BuildIndexRequest.table)
  
  return table_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildIndexRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.BuildIndexRequest.table)
}

// string index_type = 2;
inline void BuildIndexRequest::clear_index_type() {
  index_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildIndexRequest::index_type() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.BuildIndexRequest.index_type)
  return index_type_.GetNoArena();
}
inline void BuildIndexRequest::set_index_type(const std::string& value) {
  
  index_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.BuildIndexRequest.index_type)
}
inline void BuildIndexRequest::set_index_type(std::string&& value) {
  
  index_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.BuildIndexRequest.index_type)
}
inline void BuildIndexRequest::set_index_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  index_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.BuildIndexRequest.index_type)
}
inline void BuildIndexRequest::set_index_type(const char* value, size_t size) {
  
  index_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.BuildIndexRequest.index_type)
}
inline std::string* BuildIndexRequest::mutable_index_type() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.BuildIndexRequest.index_type)
  return index_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildIndexRequest::release_index_type() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.BuildIndexRequest.index_type)
  
  return index_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildIndexRequest::set_allocated_index_type(std::string* index_type) {
  if (index_type != nullptr) {
    
  } else {
    
  }
  index_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_type);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.BuildIndexRequest.index_type)
}

// .vectordb_rpc.AnnoyParam annoy_param = 3;
inline bool BuildIndexRequest::has_annoy_param() const {
  return this != internal_default_instance() && annoy_param_ != nullptr;
}
inline void BuildIndexRequest::clear_annoy_param() {
  if (GetArenaNoVirtual() == nullptr && annoy_param_ != nullptr) {
    delete annoy_param_;
  }
  annoy_param_ = nullptr;
}
inline const ::vectordb_rpc::AnnoyParam& BuildIndexRequest::annoy_param() const {
  const ::vectordb_rpc::AnnoyParam* p = annoy_param_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.BuildIndexRequest.annoy_param)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::AnnoyParam*>(
      &::vectordb_rpc::_AnnoyParam_default_instance_);
}
inline ::vectordb_rpc::AnnoyParam* BuildIndexRequest::release_annoy_param() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.BuildIndexRequest.annoy_param)
  
  ::vectordb_rpc::AnnoyParam* temp = annoy_param_;
  annoy_param_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::AnnoyParam* BuildIndexRequest::mutable_annoy_param() {
  
  if (annoy_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::AnnoyParam>(GetArenaNoVirtual());
    annoy_param_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.BuildIndexRequest.annoy_param)
  return annoy_param_;
}
inline void BuildIndexRequest::set_allocated_annoy_param(::vectordb_rpc::AnnoyParam* annoy_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete annoy_param_;
  }
  if (annoy_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      annoy_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annoy_param, submessage_arena);
    }
    
  } else {
    
  }
  annoy_param_ = annoy_param;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.BuildIndexRequest.annoy_param)
}

// .vectordb_rpc.KNNGraphParam knn_graph_param = 4;
inline bool BuildIndexRequest::has_knn_graph_param() const {
  return this != internal_default_instance() && knn_graph_param_ != nullptr;
}
inline void BuildIndexRequest::clear_knn_graph_param() {
  if (GetArenaNoVirtual() == nullptr && knn_graph_param_ != nullptr) {
    delete knn_graph_param_;
  }
  knn_graph_param_ = nullptr;
}
inline const ::vectordb_rpc::KNNGraphParam& BuildIndexRequest::knn_graph_param() const {
  const ::vectordb_rpc::KNNGraphParam* p = knn_graph_param_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.BuildIndexRequest.knn_graph_param)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::KNNGraphParam*>(
      &::vectordb_rpc::_KNNGraphParam_default_instance_);
}
inline ::vectordb_rpc::KNNGraphParam* BuildIndexRequest::release_knn_graph_param() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.BuildIndexRequest.knn_graph_param)
  
  ::vectordb_rpc::KNNGraphParam* temp = knn_graph_param_;
  knn_graph_param_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::KNNGraphParam* BuildIndexRequest::mutable_knn_graph_param() {
  
  if (knn_graph_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::KNNGraphParam>(GetArenaNoVirtual());
    knn_graph_param_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.BuildIndexRequest.knn_graph_param)
  return knn_graph_param_;
}
inline void BuildIndexRequest::set_allocated_knn_graph_param(::vectordb_rpc::KNNGraphParam* knn_graph_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete knn_graph_param_;
  }
  if (knn_graph_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      knn_graph_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, knn_graph_param, submessage_arena);
    }
    
  } else {
    
  }
  knn_graph_param_ = knn_graph_param;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.BuildIndexRequest.knn_graph_param)
}

// -------------------------------------------------------------------

// BuildIndexReply

// int32 code = 1;
inline void BuildIndexReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BuildIndexReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.BuildIndexReply.code)
  return code_;
}
inline void BuildIndexReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.BuildIndexReply.code)
}

// string msg = 2;
inline void BuildIndexReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BuildIndexReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.BuildIndexReply.msg)
  return msg_.GetNoArena();
}
inline void BuildIndexReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.BuildIndexReply.msg)
}
inline void BuildIndexReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.BuildIndexReply.msg)
}
inline void BuildIndexReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.BuildIndexReply.msg)
}
inline void BuildIndexReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.BuildIndexReply.msg)
}
inline std::string* BuildIndexReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.BuildIndexReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BuildIndexReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.BuildIndexReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BuildIndexReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.BuildIndexReply.msg)
}

// -------------------------------------------------------------------

// DistKeyRequest

// string table = 1;
inline void DistKeyRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DistKeyRequest::table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DistKeyRequest.table)
  return table_.GetNoArena();
}
inline void DistKeyRequest::set_table(const std::string& value) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.DistKeyRequest.table)
}
inline void DistKeyRequest::set_table(std::string&& value) {
  
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.DistKeyRequest.table)
}
inline void DistKeyRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.DistKeyRequest.table)
}
inline void DistKeyRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.DistKeyRequest.table)
}
inline std::string* DistKeyRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DistKeyRequest.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DistKeyRequest::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DistKeyRequest.table)
  
  return table_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DistKeyRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DistKeyRequest.table)
}

// string key1 = 2;
inline void DistKeyRequest::clear_key1() {
  key1_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DistKeyRequest::key1() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DistKeyRequest.key1)
  return key1_.GetNoArena();
}
inline void DistKeyRequest::set_key1(const std::string& value) {
  
  key1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.DistKeyRequest.key1)
}
inline void DistKeyRequest::set_key1(std::string&& value) {
  
  key1_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.DistKeyRequest.key1)
}
inline void DistKeyRequest::set_key1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.DistKeyRequest.key1)
}
inline void DistKeyRequest::set_key1(const char* value, size_t size) {
  
  key1_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.DistKeyRequest.key1)
}
inline std::string* DistKeyRequest::mutable_key1() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DistKeyRequest.key1)
  return key1_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DistKeyRequest::release_key1() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DistKeyRequest.key1)
  
  return key1_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DistKeyRequest::set_allocated_key1(std::string* key1) {
  if (key1 != nullptr) {
    
  } else {
    
  }
  key1_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key1);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DistKeyRequest.key1)
}

// string key2 = 3;
inline void DistKeyRequest::clear_key2() {
  key2_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DistKeyRequest::key2() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DistKeyRequest.key2)
  return key2_.GetNoArena();
}
inline void DistKeyRequest::set_key2(const std::string& value) {
  
  key2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.DistKeyRequest.key2)
}
inline void DistKeyRequest::set_key2(std::string&& value) {
  
  key2_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.DistKeyRequest.key2)
}
inline void DistKeyRequest::set_key2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.DistKeyRequest.key2)
}
inline void DistKeyRequest::set_key2(const char* value, size_t size) {
  
  key2_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.DistKeyRequest.key2)
}
inline std::string* DistKeyRequest::mutable_key2() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DistKeyRequest.key2)
  return key2_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DistKeyRequest::release_key2() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DistKeyRequest.key2)
  
  return key2_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DistKeyRequest::set_allocated_key2(std::string* key2) {
  if (key2 != nullptr) {
    
  } else {
    
  }
  key2_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key2);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DistKeyRequest.key2)
}

// -------------------------------------------------------------------

// DistKeyReply

// int32 code = 1;
inline void DistKeyReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DistKeyReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DistKeyReply.code)
  return code_;
}
inline void DistKeyReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.DistKeyReply.code)
}

// string msg = 2;
inline void DistKeyReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DistKeyReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DistKeyReply.msg)
  return msg_.GetNoArena();
}
inline void DistKeyReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.DistKeyReply.msg)
}
inline void DistKeyReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.DistKeyReply.msg)
}
inline void DistKeyReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.DistKeyReply.msg)
}
inline void DistKeyReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.DistKeyReply.msg)
}
inline std::string* DistKeyReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DistKeyReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DistKeyReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DistKeyReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DistKeyReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DistKeyReply.msg)
}

// float distance = 3;
inline void DistKeyReply::clear_distance() {
  distance_ = 0;
}
inline float DistKeyReply::distance() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DistKeyReply.distance)
  return distance_;
}
inline void DistKeyReply::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.DistKeyReply.distance)
}

// -------------------------------------------------------------------

// PutVecRequest

// string table = 1;
inline void PutVecRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PutVecRequest::table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.PutVecRequest.table)
  return table_.GetNoArena();
}
inline void PutVecRequest::set_table(const std::string& value) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.PutVecRequest.table)
}
inline void PutVecRequest::set_table(std::string&& value) {
  
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.PutVecRequest.table)
}
inline void PutVecRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.PutVecRequest.table)
}
inline void PutVecRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.PutVecRequest.table)
}
inline std::string* PutVecRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.PutVecRequest.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PutVecRequest::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.PutVecRequest.table)
  
  return table_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PutVecRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.PutVecRequest.table)
}

// .vectordb_rpc.VecObj vec_obj = 2;
inline bool PutVecRequest::has_vec_obj() const {
  return this != internal_default_instance() && vec_obj_ != nullptr;
}
inline void PutVecRequest::clear_vec_obj() {
  if (GetArenaNoVirtual() == nullptr && vec_obj_ != nullptr) {
    delete vec_obj_;
  }
  vec_obj_ = nullptr;
}
inline const ::vectordb_rpc::VecObj& PutVecRequest::vec_obj() const {
  const ::vectordb_rpc::VecObj* p = vec_obj_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.PutVecRequest.vec_obj)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::VecObj*>(
      &::vectordb_rpc::_VecObj_default_instance_);
}
inline ::vectordb_rpc::VecObj* PutVecRequest::release_vec_obj() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.PutVecRequest.vec_obj)
  
  ::vectordb_rpc::VecObj* temp = vec_obj_;
  vec_obj_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::VecObj* PutVecRequest::mutable_vec_obj() {
  
  if (vec_obj_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::VecObj>(GetArenaNoVirtual());
    vec_obj_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.PutVecRequest.vec_obj)
  return vec_obj_;
}
inline void PutVecRequest::set_allocated_vec_obj(::vectordb_rpc::VecObj* vec_obj) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vec_obj_;
  }
  if (vec_obj) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vec_obj = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec_obj, submessage_arena);
    }
    
  } else {
    
  }
  vec_obj_ = vec_obj;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.PutVecRequest.vec_obj)
}

// -------------------------------------------------------------------

// PutVecReply

// int32 code = 1;
inline void PutVecReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PutVecReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.PutVecReply.code)
  return code_;
}
inline void PutVecReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.PutVecReply.code)
}

// string msg = 2;
inline void PutVecReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PutVecReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.PutVecReply.msg)
  return msg_.GetNoArena();
}
inline void PutVecReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.PutVecReply.msg)
}
inline void PutVecReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.PutVecReply.msg)
}
inline void PutVecReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.PutVecReply.msg)
}
inline void PutVecReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.PutVecReply.msg)
}
inline std::string* PutVecReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.PutVecReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PutVecReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.PutVecReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PutVecReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.PutVecReply.msg)
}

// -------------------------------------------------------------------

// GetVecRequest

// string table = 1;
inline void GetVecRequest::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetVecRequest::table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetVecRequest.table)
  return table_.GetNoArena();
}
inline void GetVecRequest::set_table(const std::string& value) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetVecRequest.table)
}
inline void GetVecRequest::set_table(std::string&& value) {
  
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetVecRequest.table)
}
inline void GetVecRequest::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetVecRequest.table)
}
inline void GetVecRequest::set_table(const char* value, size_t size) {
  
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetVecRequest.table)
}
inline std::string* GetVecRequest::mutable_table() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetVecRequest.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetVecRequest::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetVecRequest.table)
  
  return table_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetVecRequest::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetVecRequest.table)
}

// string key = 2;
inline void GetVecRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetVecRequest::key() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetVecRequest.key)
  return key_.GetNoArena();
}
inline void GetVecRequest::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetVecRequest.key)
}
inline void GetVecRequest::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetVecRequest.key)
}
inline void GetVecRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetVecRequest.key)
}
inline void GetVecRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetVecRequest.key)
}
inline std::string* GetVecRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetVecRequest.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetVecRequest::release_key() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetVecRequest.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetVecRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetVecRequest.key)
}

// -------------------------------------------------------------------

// GetVecReply

// int32 code = 1;
inline void GetVecReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetVecReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetVecReply.code)
  return code_;
}
inline void GetVecReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetVecReply.code)
}

// string msg = 2;
inline void GetVecReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetVecReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetVecReply.msg)
  return msg_.GetNoArena();
}
inline void GetVecReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.GetVecReply.msg)
}
inline void GetVecReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.GetVecReply.msg)
}
inline void GetVecReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.GetVecReply.msg)
}
inline void GetVecReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.GetVecReply.msg)
}
inline std::string* GetVecReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetVecReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetVecReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetVecReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetVecReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetVecReply.msg)
}

// .vectordb_rpc.VecObj vec_obj = 3;
inline bool GetVecReply::has_vec_obj() const {
  return this != internal_default_instance() && vec_obj_ != nullptr;
}
inline void GetVecReply::clear_vec_obj() {
  if (GetArenaNoVirtual() == nullptr && vec_obj_ != nullptr) {
    delete vec_obj_;
  }
  vec_obj_ = nullptr;
}
inline const ::vectordb_rpc::VecObj& GetVecReply::vec_obj() const {
  const ::vectordb_rpc::VecObj* p = vec_obj_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.GetVecReply.vec_obj)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::VecObj*>(
      &::vectordb_rpc::_VecObj_default_instance_);
}
inline ::vectordb_rpc::VecObj* GetVecReply::release_vec_obj() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.GetVecReply.vec_obj)
  
  ::vectordb_rpc::VecObj* temp = vec_obj_;
  vec_obj_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::VecObj* GetVecReply::mutable_vec_obj() {
  
  if (vec_obj_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::VecObj>(GetArenaNoVirtual());
    vec_obj_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.GetVecReply.vec_obj)
  return vec_obj_;
}
inline void GetVecReply::set_allocated_vec_obj(::vectordb_rpc::VecObj* vec_obj) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vec_obj_;
  }
  if (vec_obj) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vec_obj = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vec_obj, submessage_arena);
    }
    
  } else {
    
  }
  vec_obj_ = vec_obj;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.GetVecReply.vec_obj)
}

// -------------------------------------------------------------------

// Replica

// int32 id = 1;
inline void Replica::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Replica::id() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Replica.id)
  return id_;
}
inline void Replica::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Replica.id)
}

// string name = 2;
inline void Replica::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Replica::name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Replica.name)
  return name_.GetNoArena();
}
inline void Replica::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Replica.name)
}
inline void Replica::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Replica.name)
}
inline void Replica::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Replica.name)
}
inline void Replica::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Replica.name)
}
inline std::string* Replica::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Replica.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Replica::release_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Replica.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Replica::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Replica.name)
}

// string table_name = 3;
inline void Replica::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Replica::table_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Replica.table_name)
  return table_name_.GetNoArena();
}
inline void Replica::set_table_name(const std::string& value) {
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Replica.table_name)
}
inline void Replica::set_table_name(std::string&& value) {
  
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Replica.table_name)
}
inline void Replica::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Replica.table_name)
}
inline void Replica::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Replica.table_name)
}
inline std::string* Replica::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Replica.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Replica::release_table_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Replica.table_name)
  
  return table_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Replica::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Replica.table_name)
}

// string partition_name = 4;
inline void Replica::clear_partition_name() {
  partition_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Replica::partition_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Replica.partition_name)
  return partition_name_.GetNoArena();
}
inline void Replica::set_partition_name(const std::string& value) {
  
  partition_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Replica.partition_name)
}
inline void Replica::set_partition_name(std::string&& value) {
  
  partition_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Replica.partition_name)
}
inline void Replica::set_partition_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partition_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Replica.partition_name)
}
inline void Replica::set_partition_name(const char* value, size_t size) {
  
  partition_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Replica.partition_name)
}
inline std::string* Replica::mutable_partition_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Replica.partition_name)
  return partition_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Replica::release_partition_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Replica.partition_name)
  
  return partition_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Replica::set_allocated_partition_name(std::string* partition_name) {
  if (partition_name != nullptr) {
    
  } else {
    
  }
  partition_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Replica.partition_name)
}

// string address = 5;
inline void Replica::clear_address() {
  address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Replica::address() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Replica.address)
  return address_.GetNoArena();
}
inline void Replica::set_address(const std::string& value) {
  
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Replica.address)
}
inline void Replica::set_address(std::string&& value) {
  
  address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Replica.address)
}
inline void Replica::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Replica.address)
}
inline void Replica::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Replica.address)
}
inline std::string* Replica::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Replica.address)
  return address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Replica::release_address() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Replica.address)
  
  return address_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Replica::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Replica.address)
}

// string path = 6;
inline void Replica::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Replica::path() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Replica.path)
  return path_.GetNoArena();
}
inline void Replica::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Replica.path)
}
inline void Replica::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Replica.path)
}
inline void Replica::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Replica.path)
}
inline void Replica::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Replica.path)
}
inline std::string* Replica::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Replica.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Replica::release_path() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Replica.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Replica::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Replica.path)
}

// -------------------------------------------------------------------

// Partition

// int32 id = 1;
inline void Partition::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Partition::id() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Partition.id)
  return id_;
}
inline void Partition::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Partition.id)
}

// string name = 2;
inline void Partition::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Partition::name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Partition.name)
  return name_.GetNoArena();
}
inline void Partition::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Partition.name)
}
inline void Partition::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Partition.name)
}
inline void Partition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Partition.name)
}
inline void Partition::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Partition.name)
}
inline std::string* Partition::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Partition.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Partition::release_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Partition.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Partition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Partition.name)
}

// string table_name = 3;
inline void Partition::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Partition::table_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Partition.table_name)
  return table_name_.GetNoArena();
}
inline void Partition::set_table_name(const std::string& value) {
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Partition.table_name)
}
inline void Partition::set_table_name(std::string&& value) {
  
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Partition.table_name)
}
inline void Partition::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Partition.table_name)
}
inline void Partition::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Partition.table_name)
}
inline std::string* Partition::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Partition.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Partition::release_table_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Partition.table_name)
  
  return table_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Partition::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Partition.table_name)
}

// int32 replica_num = 4;
inline void Partition::clear_replica_num() {
  replica_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Partition::replica_num() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Partition.replica_num)
  return replica_num_;
}
inline void Partition::set_replica_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  replica_num_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Partition.replica_num)
}

// string path = 5;
inline void Partition::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Partition::path() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Partition.path)
  return path_.GetNoArena();
}
inline void Partition::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Partition.path)
}
inline void Partition::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Partition.path)
}
inline void Partition::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Partition.path)
}
inline void Partition::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Partition.path)
}
inline std::string* Partition::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Partition.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Partition::release_path() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Partition.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Partition::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Partition.path)
}

// repeated .vectordb_rpc.Replica replicas = 6;
inline int Partition::replicas_size() const {
  return replicas_.size();
}
inline void Partition::clear_replicas() {
  replicas_.Clear();
}
inline ::vectordb_rpc::Replica* Partition::mutable_replicas(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Partition.replicas)
  return replicas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Replica >*
Partition::mutable_replicas() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.Partition.replicas)
  return &replicas_;
}
inline const ::vectordb_rpc::Replica& Partition::replicas(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Partition.replicas)
  return replicas_.Get(index);
}
inline ::vectordb_rpc::Replica* Partition::add_replicas() {
  // @@protoc_insertion_point(field_add:vectordb_rpc.Partition.replicas)
  return replicas_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Replica >&
Partition::replicas() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.Partition.replicas)
  return replicas_;
}

// -------------------------------------------------------------------

// Index

// string index_name = 1;
inline void Index::clear_index_name() {
  index_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Index::index_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Index.index_name)
  return index_name_.GetNoArena();
}
inline void Index::set_index_name(const std::string& value) {
  
  index_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Index.index_name)
}
inline void Index::set_index_name(std::string&& value) {
  
  index_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Index.index_name)
}
inline void Index::set_index_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  index_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Index.index_name)
}
inline void Index::set_index_name(const char* value, size_t size) {
  
  index_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Index.index_name)
}
inline std::string* Index::mutable_index_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Index.index_name)
  return index_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Index::release_index_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Index.index_name)
  
  return index_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Index::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  index_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Index.index_name)
}

// string index_type = 2;
inline void Index::clear_index_type() {
  index_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Index::index_type() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Index.index_type)
  return index_type_.GetNoArena();
}
inline void Index::set_index_type(const std::string& value) {
  
  index_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Index.index_type)
}
inline void Index::set_index_type(std::string&& value) {
  
  index_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Index.index_type)
}
inline void Index::set_index_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  index_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Index.index_type)
}
inline void Index::set_index_type(const char* value, size_t size) {
  
  index_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Index.index_type)
}
inline std::string* Index::mutable_index_type() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Index.index_type)
  return index_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Index::release_index_type() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Index.index_type)
  
  return index_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Index::set_allocated_index_type(std::string* index_type) {
  if (index_type != nullptr) {
    
  } else {
    
  }
  index_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_type);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Index.index_type)
}

// -------------------------------------------------------------------

// Table

// string name = 1;
inline void Table::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Table::name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.name)
  return name_.GetNoArena();
}
inline void Table::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Table.name)
}
inline void Table::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Table.name)
}
inline void Table::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Table.name)
}
inline void Table::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Table.name)
}
inline std::string* Table::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Table.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Table::release_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Table.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Table::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Table.name)
}

// int32 partition_num = 2;
inline void Table::clear_partition_num() {
  partition_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Table::partition_num() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.partition_num)
  return partition_num_;
}
inline void Table::set_partition_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  partition_num_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Table.partition_num)
}

// int32 replica_num = 3;
inline void Table::clear_replica_num() {
  replica_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Table::replica_num() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.replica_num)
  return replica_num_;
}
inline void Table::set_replica_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  replica_num_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Table.replica_num)
}

// string engine_type = 4;
inline void Table::clear_engine_type() {
  engine_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Table::engine_type() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.engine_type)
  return engine_type_.GetNoArena();
}
inline void Table::set_engine_type(const std::string& value) {
  
  engine_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Table.engine_type)
}
inline void Table::set_engine_type(std::string&& value) {
  
  engine_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Table.engine_type)
}
inline void Table::set_engine_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  engine_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Table.engine_type)
}
inline void Table::set_engine_type(const char* value, size_t size) {
  
  engine_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Table.engine_type)
}
inline std::string* Table::mutable_engine_type() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Table.engine_type)
  return engine_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Table::release_engine_type() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Table.engine_type)
  
  return engine_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Table::set_allocated_engine_type(std::string* engine_type) {
  if (engine_type != nullptr) {
    
  } else {
    
  }
  engine_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), engine_type);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Table.engine_type)
}

// string path = 5;
inline void Table::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Table::path() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.path)
  return path_.GetNoArena();
}
inline void Table::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.Table.path)
}
inline void Table::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.Table.path)
}
inline void Table::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.Table.path)
}
inline void Table::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.Table.path)
}
inline std::string* Table::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Table.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Table::release_path() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.Table.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Table::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.Table.path)
}

// repeated .vectordb_rpc.Partition partitions = 6;
inline int Table::partitions_size() const {
  return partitions_.size();
}
inline void Table::clear_partitions() {
  partitions_.Clear();
}
inline ::vectordb_rpc::Partition* Table::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Table.partitions)
  return partitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Partition >*
Table::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.Table.partitions)
  return &partitions_;
}
inline const ::vectordb_rpc::Partition& Table::partitions(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.partitions)
  return partitions_.Get(index);
}
inline ::vectordb_rpc::Partition* Table::add_partitions() {
  // @@protoc_insertion_point(field_add:vectordb_rpc.Table.partitions)
  return partitions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Partition >&
Table::partitions() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.Table.partitions)
  return partitions_;
}

// repeated .vectordb_rpc.Index indices = 7;
inline int Table::indices_size() const {
  return indices_.size();
}
inline void Table::clear_indices() {
  indices_.Clear();
}
inline ::vectordb_rpc::Index* Table::mutable_indices(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.Table.indices)
  return indices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Index >*
Table::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.Table.indices)
  return &indices_;
}
inline const ::vectordb_rpc::Index& Table::indices(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.indices)
  return indices_.Get(index);
}
inline ::vectordb_rpc::Index* Table::add_indices() {
  // @@protoc_insertion_point(field_add:vectordb_rpc.Table.indices)
  return indices_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vectordb_rpc::Index >&
Table::indices() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.Table.indices)
  return indices_;
}

// int32 dim = 8;
inline void Table::clear_dim() {
  dim_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Table::dim() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.Table.dim)
  return dim_;
}
inline void Table::set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dim_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.Table.dim)
}

// -------------------------------------------------------------------

// TableNames

// repeated string table_names = 1;
inline int TableNames::table_names_size() const {
  return table_names_.size();
}
inline void TableNames::clear_table_names() {
  table_names_.Clear();
}
inline const std::string& TableNames::table_names(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.TableNames.table_names)
  return table_names_.Get(index);
}
inline std::string* TableNames::mutable_table_names(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.TableNames.table_names)
  return table_names_.Mutable(index);
}
inline void TableNames::set_table_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.TableNames.table_names)
  table_names_.Mutable(index)->assign(value);
}
inline void TableNames::set_table_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.TableNames.table_names)
  table_names_.Mutable(index)->assign(std::move(value));
}
inline void TableNames::set_table_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  table_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.TableNames.table_names)
}
inline void TableNames::set_table_names(int index, const char* value, size_t size) {
  table_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.TableNames.table_names)
}
inline std::string* TableNames::add_table_names() {
  // @@protoc_insertion_point(field_add_mutable:vectordb_rpc.TableNames.table_names)
  return table_names_.Add();
}
inline void TableNames::add_table_names(const std::string& value) {
  table_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vectordb_rpc.TableNames.table_names)
}
inline void TableNames::add_table_names(std::string&& value) {
  table_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vectordb_rpc.TableNames.table_names)
}
inline void TableNames::add_table_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  table_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vectordb_rpc.TableNames.table_names)
}
inline void TableNames::add_table_names(const char* value, size_t size) {
  table_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vectordb_rpc.TableNames.table_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TableNames::table_names() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.TableNames.table_names)
  return table_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TableNames::mutable_table_names() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.TableNames.table_names)
  return &table_names_;
}

// -------------------------------------------------------------------

// PingRequest

// string msg = 1;
inline void PingRequest::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PingRequest::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.PingRequest.msg)
  return msg_.GetNoArena();
}
inline void PingRequest::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.PingRequest.msg)
}
inline void PingRequest::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.PingRequest.msg)
}
inline void PingRequest::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.PingRequest.msg)
}
inline void PingRequest::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.PingRequest.msg)
}
inline std::string* PingRequest::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.PingRequest.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PingRequest::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.PingRequest.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PingRequest::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.PingRequest.msg)
}

// -------------------------------------------------------------------

// PingReply

// string msg = 1;
inline void PingReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PingReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.PingReply.msg)
  return msg_.GetNoArena();
}
inline void PingReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.PingReply.msg)
}
inline void PingReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.PingReply.msg)
}
inline void PingReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.PingReply.msg)
}
inline void PingReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.PingReply.msg)
}
inline std::string* PingReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.PingReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PingReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.PingReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PingReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.PingReply.msg)
}

// -------------------------------------------------------------------

// CreateTableRequest

// string table_name = 1;
inline void CreateTableRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CreateTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.CreateTableRequest.table_name)
  return table_name_.GetNoArena();
}
inline void CreateTableRequest::set_table_name(const std::string& value) {
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.CreateTableRequest.table_name)
}
inline void CreateTableRequest::set_table_name(std::string&& value) {
  
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.CreateTableRequest.table_name)
}
inline void CreateTableRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.CreateTableRequest.table_name)
}
inline void CreateTableRequest::set_table_name(const char* value, size_t size) {
  
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.CreateTableRequest.table_name)
}
inline std::string* CreateTableRequest::mutable_table_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.CreateTableRequest.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CreateTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.CreateTableRequest.table_name)
  
  return table_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.CreateTableRequest.table_name)
}

// int32 partition_num = 2;
inline void CreateTableRequest::clear_partition_num() {
  partition_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTableRequest::partition_num() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.CreateTableRequest.partition_num)
  return partition_num_;
}
inline void CreateTableRequest::set_partition_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  partition_num_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.CreateTableRequest.partition_num)
}

// int32 replica_num = 3;
inline void CreateTableRequest::clear_replica_num() {
  replica_num_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTableRequest::replica_num() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.CreateTableRequest.replica_num)
  return replica_num_;
}
inline void CreateTableRequest::set_replica_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  replica_num_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.CreateTableRequest.replica_num)
}

// int32 dim = 4;
inline void CreateTableRequest::clear_dim() {
  dim_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTableRequest::dim() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.CreateTableRequest.dim)
  return dim_;
}
inline void CreateTableRequest::set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dim_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.CreateTableRequest.dim)
}

// -------------------------------------------------------------------

// CreateTableReply

// int32 code = 1;
inline void CreateTableReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateTableReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.CreateTableReply.code)
  return code_;
}
inline void CreateTableReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.CreateTableReply.code)
}

// string msg = 2;
inline void CreateTableReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CreateTableReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.CreateTableReply.msg)
  return msg_.GetNoArena();
}
inline void CreateTableReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.CreateTableReply.msg)
}
inline void CreateTableReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.CreateTableReply.msg)
}
inline void CreateTableReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.CreateTableReply.msg)
}
inline void CreateTableReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.CreateTableReply.msg)
}
inline std::string* CreateTableReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.CreateTableReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CreateTableReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.CreateTableReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTableReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.CreateTableReply.msg)
}

// -------------------------------------------------------------------

// ShowTablesRequest

// -------------------------------------------------------------------

// ShowTablesReply

// repeated string tables = 1;
inline int ShowTablesReply::tables_size() const {
  return tables_.size();
}
inline void ShowTablesReply::clear_tables() {
  tables_.Clear();
}
inline const std::string& ShowTablesReply::tables(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.ShowTablesReply.tables)
  return tables_.Get(index);
}
inline std::string* ShowTablesReply::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.ShowTablesReply.tables)
  return tables_.Mutable(index);
}
inline void ShowTablesReply::set_tables(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.ShowTablesReply.tables)
  tables_.Mutable(index)->assign(value);
}
inline void ShowTablesReply::set_tables(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.ShowTablesReply.tables)
  tables_.Mutable(index)->assign(std::move(value));
}
inline void ShowTablesReply::set_tables(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.ShowTablesReply.tables)
}
inline void ShowTablesReply::set_tables(int index, const char* value, size_t size) {
  tables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.ShowTablesReply.tables)
}
inline std::string* ShowTablesReply::add_tables() {
  // @@protoc_insertion_point(field_add_mutable:vectordb_rpc.ShowTablesReply.tables)
  return tables_.Add();
}
inline void ShowTablesReply::add_tables(const std::string& value) {
  tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vectordb_rpc.ShowTablesReply.tables)
}
inline void ShowTablesReply::add_tables(std::string&& value) {
  tables_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vectordb_rpc.ShowTablesReply.tables)
}
inline void ShowTablesReply::add_tables(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vectordb_rpc.ShowTablesReply.tables)
}
inline void ShowTablesReply::add_tables(const char* value, size_t size) {
  tables_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vectordb_rpc.ShowTablesReply.tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShowTablesReply::tables() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.ShowTablesReply.tables)
  return tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShowTablesReply::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.ShowTablesReply.tables)
  return &tables_;
}

// -------------------------------------------------------------------

// DescribeRequest

// string name = 1;
inline void DescribeRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DescribeRequest::name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeRequest.name)
  return name_.GetNoArena();
}
inline void DescribeRequest::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.DescribeRequest.name)
}
inline void DescribeRequest::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.DescribeRequest.name)
}
inline void DescribeRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.DescribeRequest.name)
}
inline void DescribeRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.DescribeRequest.name)
}
inline std::string* DescribeRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DescribeRequest.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DescribeRequest::release_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DescribeRequest.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DescribeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DescribeRequest.name)
}

// -------------------------------------------------------------------

// DescribeReply

// int32 code = 1;
inline void DescribeReply::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DescribeReply::code() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.code)
  return code_;
}
inline void DescribeReply::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.DescribeReply.code)
}

// string msg = 2;
inline void DescribeReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DescribeReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.msg)
  return msg_.GetNoArena();
}
inline void DescribeReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.DescribeReply.msg)
}
inline void DescribeReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.DescribeReply.msg)
}
inline void DescribeReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.DescribeReply.msg)
}
inline void DescribeReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.DescribeReply.msg)
}
inline std::string* DescribeReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DescribeReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DescribeReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DescribeReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DescribeReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DescribeReply.msg)
}

// bool describe_table = 3;
inline void DescribeReply::clear_describe_table() {
  describe_table_ = false;
}
inline bool DescribeReply::describe_table() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.describe_table)
  return describe_table_;
}
inline void DescribeReply::set_describe_table(bool value) {
  
  describe_table_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.DescribeReply.describe_table)
}

// .vectordb_rpc.Table table = 4;
inline bool DescribeReply::has_table() const {
  return this != internal_default_instance() && table_ != nullptr;
}
inline void DescribeReply::clear_table() {
  if (GetArenaNoVirtual() == nullptr && table_ != nullptr) {
    delete table_;
  }
  table_ = nullptr;
}
inline const ::vectordb_rpc::Table& DescribeReply::table() const {
  const ::vectordb_rpc::Table* p = table_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.table)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::Table*>(
      &::vectordb_rpc::_Table_default_instance_);
}
inline ::vectordb_rpc::Table* DescribeReply::release_table() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DescribeReply.table)
  
  ::vectordb_rpc::Table* temp = table_;
  table_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::Table* DescribeReply::mutable_table() {
  
  if (table_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::Table>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DescribeReply.table)
  return table_;
}
inline void DescribeReply::set_allocated_table(::vectordb_rpc::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_;
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DescribeReply.table)
}

// bool describe_partition = 5;
inline void DescribeReply::clear_describe_partition() {
  describe_partition_ = false;
}
inline bool DescribeReply::describe_partition() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.describe_partition)
  return describe_partition_;
}
inline void DescribeReply::set_describe_partition(bool value) {
  
  describe_partition_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.DescribeReply.describe_partition)
}

// .vectordb_rpc.Partition partition = 6;
inline bool DescribeReply::has_partition() const {
  return this != internal_default_instance() && partition_ != nullptr;
}
inline void DescribeReply::clear_partition() {
  if (GetArenaNoVirtual() == nullptr && partition_ != nullptr) {
    delete partition_;
  }
  partition_ = nullptr;
}
inline const ::vectordb_rpc::Partition& DescribeReply::partition() const {
  const ::vectordb_rpc::Partition* p = partition_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.partition)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::Partition*>(
      &::vectordb_rpc::_Partition_default_instance_);
}
inline ::vectordb_rpc::Partition* DescribeReply::release_partition() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DescribeReply.partition)
  
  ::vectordb_rpc::Partition* temp = partition_;
  partition_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::Partition* DescribeReply::mutable_partition() {
  
  if (partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::Partition>(GetArenaNoVirtual());
    partition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DescribeReply.partition)
  return partition_;
}
inline void DescribeReply::set_allocated_partition(::vectordb_rpc::Partition* partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete partition_;
  }
  if (partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition, submessage_arena);
    }
    
  } else {
    
  }
  partition_ = partition;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DescribeReply.partition)
}

// bool describe_replica = 7;
inline void DescribeReply::clear_describe_replica() {
  describe_replica_ = false;
}
inline bool DescribeReply::describe_replica() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.describe_replica)
  return describe_replica_;
}
inline void DescribeReply::set_describe_replica(bool value) {
  
  describe_replica_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.DescribeReply.describe_replica)
}

// .vectordb_rpc.Replica replica = 8;
inline bool DescribeReply::has_replica() const {
  return this != internal_default_instance() && replica_ != nullptr;
}
inline void DescribeReply::clear_replica() {
  if (GetArenaNoVirtual() == nullptr && replica_ != nullptr) {
    delete replica_;
  }
  replica_ = nullptr;
}
inline const ::vectordb_rpc::Replica& DescribeReply::replica() const {
  const ::vectordb_rpc::Replica* p = replica_;
  // @@protoc_insertion_point(field_get:vectordb_rpc.DescribeReply.replica)
  return p != nullptr ? *p : *reinterpret_cast<const ::vectordb_rpc::Replica*>(
      &::vectordb_rpc::_Replica_default_instance_);
}
inline ::vectordb_rpc::Replica* DescribeReply::release_replica() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.DescribeReply.replica)
  
  ::vectordb_rpc::Replica* temp = replica_;
  replica_ = nullptr;
  return temp;
}
inline ::vectordb_rpc::Replica* DescribeReply::mutable_replica() {
  
  if (replica_ == nullptr) {
    auto* p = CreateMaybeMessage<::vectordb_rpc::Replica>(GetArenaNoVirtual());
    replica_ = p;
  }
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.DescribeReply.replica)
  return replica_;
}
inline void DescribeReply::set_allocated_replica(::vectordb_rpc::Replica* replica) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete replica_;
  }
  if (replica) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      replica = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replica, submessage_arena);
    }
    
  } else {
    
  }
  replica_ = replica;
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.DescribeReply.replica)
}

// -------------------------------------------------------------------

// InfoRequest

// -------------------------------------------------------------------

// InfoReply

// string msg = 1;
inline void InfoReply::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& InfoReply::msg() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.InfoReply.msg)
  return msg_.GetNoArena();
}
inline void InfoReply::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.InfoReply.msg)
}
inline void InfoReply::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.InfoReply.msg)
}
inline void InfoReply::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.InfoReply.msg)
}
inline void InfoReply::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.InfoReply.msg)
}
inline std::string* InfoReply::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.InfoReply.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InfoReply::release_msg() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.InfoReply.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InfoReply::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.InfoReply.msg)
}

// -------------------------------------------------------------------

// VEngineMeta

// int32 dim = 1;
inline void VEngineMeta::clear_dim() {
  dim_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VEngineMeta::dim() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VEngineMeta.dim)
  return dim_;
}
inline void VEngineMeta::set_dim(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dim_ = value;
  // @@protoc_insertion_point(field_set:vectordb_rpc.VEngineMeta.dim)
}

// string replica_name = 2;
inline void VEngineMeta::clear_replica_name() {
  replica_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VEngineMeta::replica_name() const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VEngineMeta.replica_name)
  return replica_name_.GetNoArena();
}
inline void VEngineMeta::set_replica_name(const std::string& value) {
  
  replica_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vectordb_rpc.VEngineMeta.replica_name)
}
inline void VEngineMeta::set_replica_name(std::string&& value) {
  
  replica_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vectordb_rpc.VEngineMeta.replica_name)
}
inline void VEngineMeta::set_replica_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  replica_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VEngineMeta.replica_name)
}
inline void VEngineMeta::set_replica_name(const char* value, size_t size) {
  
  replica_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VEngineMeta.replica_name)
}
inline std::string* VEngineMeta::mutable_replica_name() {
  
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VEngineMeta.replica_name)
  return replica_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VEngineMeta::release_replica_name() {
  // @@protoc_insertion_point(field_release:vectordb_rpc.VEngineMeta.replica_name)
  
  return replica_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VEngineMeta::set_allocated_replica_name(std::string* replica_name) {
  if (replica_name != nullptr) {
    
  } else {
    
  }
  replica_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), replica_name);
  // @@protoc_insertion_point(field_set_allocated:vectordb_rpc.VEngineMeta.replica_name)
}

// repeated string index_names = 3;
inline int VEngineMeta::index_names_size() const {
  return index_names_.size();
}
inline void VEngineMeta::clear_index_names() {
  index_names_.Clear();
}
inline const std::string& VEngineMeta::index_names(int index) const {
  // @@protoc_insertion_point(field_get:vectordb_rpc.VEngineMeta.index_names)
  return index_names_.Get(index);
}
inline std::string* VEngineMeta::mutable_index_names(int index) {
  // @@protoc_insertion_point(field_mutable:vectordb_rpc.VEngineMeta.index_names)
  return index_names_.Mutable(index);
}
inline void VEngineMeta::set_index_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.VEngineMeta.index_names)
  index_names_.Mutable(index)->assign(value);
}
inline void VEngineMeta::set_index_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:vectordb_rpc.VEngineMeta.index_names)
  index_names_.Mutable(index)->assign(std::move(value));
}
inline void VEngineMeta::set_index_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  index_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:vectordb_rpc.VEngineMeta.index_names)
}
inline void VEngineMeta::set_index_names(int index, const char* value, size_t size) {
  index_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:vectordb_rpc.VEngineMeta.index_names)
}
inline std::string* VEngineMeta::add_index_names() {
  // @@protoc_insertion_point(field_add_mutable:vectordb_rpc.VEngineMeta.index_names)
  return index_names_.Add();
}
inline void VEngineMeta::add_index_names(const std::string& value) {
  index_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:vectordb_rpc.VEngineMeta.index_names)
}
inline void VEngineMeta::add_index_names(std::string&& value) {
  index_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:vectordb_rpc.VEngineMeta.index_names)
}
inline void VEngineMeta::add_index_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  index_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:vectordb_rpc.VEngineMeta.index_names)
}
inline void VEngineMeta::add_index_names(const char* value, size_t size) {
  index_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:vectordb_rpc.VEngineMeta.index_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VEngineMeta::index_names() const {
  // @@protoc_insertion_point(field_list:vectordb_rpc.VEngineMeta.index_names)
  return index_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VEngineMeta::mutable_index_names() {
  // @@protoc_insertion_point(field_mutable_list:vectordb_rpc.VEngineMeta.index_names)
  return &index_names_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vectordb_rpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vectordb_5frpc_2eproto
